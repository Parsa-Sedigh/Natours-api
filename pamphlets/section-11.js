/* 148-1. Section Intro:
We're gonna model all the data for application in multiple ways and also look at how to implement our data model using advanced mongoose features.
By the end of this section, our api will be fully functioning with all routes and all resources, a complete authentication and authorization and
also all established relationships between all the data sets.
Let's get started with mongodb data modeling.*/
/* 149-2. MongoDB Data Modelling:
One of the most crucial steps in building data intensive apps, is to model all this data in mongodb.

Data ... What?
Data modeling:
Data modeling is the process of taking unstructured data generated by a real world scenario and then structure it into a logical data model in a
database and we do that according to a set of criteria which we're gonna look at in this video.
For example, let's say we want to design an online shop data model. There will be initially a ton of unstructured data that we know we need. Stuff like
products, categories, customers, orders, shopping carts, suppliers and ... . Our goal with data modeling is to then structure this data into a logical
way. Reflecting the real-world relationships that exist between some of these data sets. A bit like you can see in the slide.
There is not just one unique correct way of structuring the data. But a common process is described through 4 steps:
1) In the first step, we look at how to identify different types of relationships between data.
2) Then we're gonna understand the difference between referencing or nomalization and embedding or denormalization
3) In the most crucial step, the tutor will show us his framework for deciding whether we should embed documents or reference to other documents, based on
a couple of different factors.
4) Also we have to quickly talk about different types of referencing. Because that's crucial if that is the type of design that we choose for our data.

Recap of steps:
1) Different types of relationships between data
2) Referencing / normalization vs. embedding/denormalization
3) embedding or referencing other documents?
4) types of referencing

The way we design data, so the way we model our data, can make or break our entire application.

➡️ 1. Types of relationships between data:
There are 3 big types of relationships: one to one, one to many and many to many.
A one to one relationship between data is when one field can only have one value. So in our movie application example, one movie will only ever
have one name and this is an example of one to one relationship. But these relationships are not really that crucial in terms of data modeling.

Now the most crucial relationships are the one to many relationships and they are so crucial, that in mongodb we actually distinguish between three types
of one to many relationships: one to a few, one to many, one to a ton or to a million or sth like that.
The different here is based on the relative AMOUNT of the 'many'. An example to a 'one to a few' relationship is that one movie can win many awards but actually just
'a few'. So movie is not gonna win a thousand awards, but it can win SOME and so this is a typical 'one to few' relationship.
Important: So you see that in general, a one to many relationship means that one document can relate to many other documents.
Now this might look a bit abstract without the json data, but that's actually the purpose here. The tutor just want to show us a conecptual overview of these
different types of relationships.
Important: In a one to many relationship, one document can relate to hundreds or thousands of other documents.
For example, one movie can have thousands of reviews in our application and so this is not really a one to few, but one to many relationship.
and finally, we have the one to a ton relationship. Imagine we wanted to implement some logging functionality in our app. So basically to know exactly what's
going on on our server. These logs can then easily grow to millions of documents and so this is a typical example of a one to tons relationship and the difference
between many and a tone, is of course a bit fuzzy, but just think if sth can grow almost to infinity, then it's definitely a one to ton relationship.
So again, the one to many relationships are the most crucial ones to know. By the way, in relational databases, there is just 'one to many' without quantifying
how much that 'many' actually is. In mongodb databased though, it is an extremely crucial difference, because it's one of the factors that we're gonna use
to decide if we should denormalize or normalize data as you will look at a bit later.

Important: The last type of relationship is the many to many, where one movie can have many actors, but at the same time, one actor can play in many movies
 and so here, the relationship goes in both directions, where before in the other types, it was only in ONE direction.
For example one movie can have many reviews but one specific review, is only for that one movie and the same goes for the awards. So one specific award
like for the best actor, goes to only one movie not multiple ones. But with movies and actors, it is indeed different. So again, one movie, starts many actors,
but one actor plays many movies and so it's a many to many relationship.

Recap:
1:1 : 1 movie can only have 1 name.
1:many : 1 movie can win MANY awards
many:many : One movie can have MANY actors, but one actor can also play in MANY movies(in this case, we're processing the relationship between movie and actor).

➡️ 2. Referencing vs. embedding:
The most crucial aspect that we need to look at about mongodb databases, is referencing and embedding two datasets.
Each time we have two related datasets, we can either represent that related data, in a referenced or normalized form or in an embedded or denormalized form and
the tutor keeps using the two related terms together, like referencing and normalizing, because you will see them both being used.
In the referenced form, we keep the two related datasets and all the documents, separated. So again, all the data is nicely separated, which is
exactly what normalized means.
Continuing the movie database example from before, we would have one movie document and one actor document for each actor. Now how do we then make the
connection between movie and the actors? So that later in our app, we can show which actors played in a particular movie. Because if they are all completey
different documents, the movie has no way of knowing about the actors.
Answer: That's where the ids come in. We use the actor _ids in order to create references on the movie document. Effectively, connecting movies with actors.
So you see that in a movie document, we have an array called actors, where we stored the _ids of all the actors. So that when we request data about a certain
movie, we can easily identify it's actors.
This type of referencing is called `child referencing`. Because it's the parent, in this case, the movie, who references it's children, which in this case, the children
are the actors. So we're really creating some sort of hierarchy here.
Now there is also parent referencing.

By the way, in relational databases, all data is always represented in normalized form. But in a nosql db like mongodb, we can denormalize data into a
denormalized form, by embedding the related documents, right into the main document. So now, we have all the relevant data about actors, right inside one main movie
document without the need for separate documents, collections and _ids.
Important: So again, if we choose to denormalize or to embed our data, we will have one main document containing all the main data, as well as the related data.
and the result of this, is that our application will need to make fewer queries to the db. Because we can get all the data about movies and actors, all at the same time,
which will of course increase our performance. Now the downside here is that we can't really query the embedded data on it's own and so if that's a
requirement for the app, you would have to choose a normalized design.
In normalized form, there is an improvement in performance, when we often need to query the related data ON IT'S OWN. Because we then can just query the
data that we need and NOT always movies and actors TOGETHER. But on the other hand, when we need to query movies and actors together, we then are gonna need
many queries to the db. So first the query for the movie and then from there, we will also need a query for the actors and that is of worst, for performance.

So when designing you db, this is the kind of stuff that you need to keep in mind.

Note: We could begin our though process with denormalized data and then come to the conclusion that it's best to normalize the data.
So when thinking about our data model, this way of organizing data works in both ways.

Now how do we decide if we should normalize or denoramlize the data?

➡️ 3. When to embed and when to reference? A practical framework:
When we have two related datasets, we have to decide if we're gonna embed the datasets or if we're gonna keep them separated and reference from one dataset to the
other. There is a decision framework where we use three criteria to take that decision.
1) We look at the type of relationships that exist between datasets
2) We try to determine the data access pattern of the dataset that we want to either embed or reference(means to analyze how often data is read and
   written in that dataset)
3) We look at data closeness, which means how much the data is really related and how we want to query the data from db.

Recap:
1) Relationship type:
How two datasets are related to each other

2) Data access patterns:
How often data is read and written. Read/write ratio

3) Data closensess:
How "much" the data is related. how we want to query

To take the decision, we need to COMBINE all of these three criteria and not just use one of them in isolation. For example, just because
criteria number one says to embed, it doesn't mean that we don't need to look at the other two criteria.

About first criteria:
Important: Usually when we have a one to few relationship, we will always embed the related dataset into the main dataset.
 In a one to many relationship, things are a bit more fuzzy. So it's okay to either embed or reference. In that case, we will have to decide according
to the other two criteria .
On a one to a ton or a many to many relationship, we usually always reference the data. That's because if we did embed in this case, we could quickly create
way too large documents, even potentially surpassing the maximum of 16 megabyte and so the solution for that is of course referencing or normalizing the data and
as a quick example, let's say that in our movie db example, we have around 100 images associated to each movie. So we could say it's a one to many relationship.
But are we gonna embed the datasets or should we rather reference them there?
Well, we don't really know. So let's take a look at the other two criteria.

About second criteria:
The second one is about data access patterns, which is just a fancy description for evalutating whether a certain dataset is mostly written to, or mostly read from.
Important: If the dataset that we're deciding about, is mostly read and the data is not updated a lot, then we should probably embed that dataset. So a high
 read/write ratio just means that there is a lot more reading than writing and again, a dataset like that, is a good candidate for embedding.
 and the reason for this is that by embedding, we only need one trip to the database per query. While for referencing, we need two trips.
 So if we embed data that is read a lot, in each query we save one trip to the database, making the entire process way more performant.
So I think that our movie image example would actually be a good candidate for embedding. Because once the 100 images are saved to the database,
they are not really updated anymore, because there is not really anything to update about an image. So it's all about reading and therefore based on this
criteria, we would embed the image documents.
Important: On the other hand, if our data is updated a lot, then we should consider referencing or normalizing the data. That's because it's more
 work for the database engine to update an embedded document than a more simple standalone document and since our main goal is performance,
 we just normalize the dataset.
In our example, let's say each movie has many reviews and each review can be marked as helpful by the user. So each time someone clicks on 'this review was helpful' in
our app, we need to update the corresponding document and this means that the data can change all the time and so this is a great candidate for normalizing. Again because
we don't want to be querying the movies all the time, if all we really wanna update is the reviews by marking them as helpful.


About third criteria(data closeness):
Data closeness is just like a measure for how much the data is related. So if the two datasets really intrinsically belong together, then they should
probably be embedded into one another.
In our example, all users can have many email addresses on their account and since they are so intrinsically connected to the user, there is no doubt emails should
be embedded into the document.
Important: Now if we frequently need to query both of datasets on their own, then that's a very good reason to normalize
 the data into two separate datasets, even if they are closely related. So imagine that in our app we have a quiz where users have to identify a movie based on
 images. This means that we're gonna query a lot of images on their own. So without necessarily querying for the movies themselves and so if we apply this
 third criteria, we come to the conclusion that we should normalize the image dataset. Because again if we implement this quiz functionality, images are gonna
 be queried on their own all the time.
So all of this shows that we should really look at all the three criteria together rather than just one of them in isolation. Because that might lead to
less optimal decisions and I say less optimal instead of wrong, because they are not really any completely right or completely wrong ways of modeling our data.
There are no hard rules, these are just like guidelines that you can follow to find the probably most correct way of structuring your data.

➡️ 4. Types of referencing:
Let's say that we have chosen to noramlize our datasets. So in other words, to reference data, then after that, we still have to choose
between three different types of referencing: child referencing, parent referencing and two-way referencing.
1- The first type is child referencing. For example in error logging example, we could potentially have millions of locked documents. So in child referencing,
we keep refrences to the related child documents, in a parent document and they're usually stored in an array. For example, each log has an _id and then in
the app document, there is that array with all of those _ids. However the problem here is that that array of _ids can become very large if there are lots of
children and this is an anti-pattern in mongodb. So sth that we should avoid at all costs. Also child referencing makes it so, that parents and children are
very tightly coupled, which is not always ideal, but that's exactly why we have parent referencing.

2- In parent referencing, it actually works the other way around. Here, in each child document, we keep a reference to the parent element. Therefore, the name
'parent referencing'. In the slide's example, the app _id is 23 and so in each log there is the `app` field with the 23 _id in it. So that the child always knows it's
parent and so in this case, the parent actually knows nothing about the children!!! Not who they are and not how many they are. So they are way more isolated
and more standalone and that can sometimes beneficial.

Which of these two types is better for this data relationship? and remember how I said that there could be millions of logs and so let's suppose
there is two million log documents. In a case of child referencing, that would mean that there are two million _id references in the app document.
Now also remember how I said that there is a 16 megabyte limit on documents. So if we kept adding and adding these child ids into the array on the parent,
then we would quickly hit that 16 megabytes limit that each Bson document can hold. Simply because that array will grow so much.
So that's not really gonna work.
On the other hand, with parent referencing, that problem is not gonna happen. We will simply have two million log documents just like before but each of them
holds _id of it's parent. But there is no array that will grow indefinitely and therefore parent referencing will be the best solution here.

Important: So the conclusion of all this, is that in general, child referencing is best used for one to a few relationships, where we know BEFOREHAND that the
 array of child documents won't grow that much. On the other hand, parent referencing is best used for one to many and one to a ton relationships like our example.

One of the most crucial principals of mongodb data modeling is that array should never be allowed to grow indefintely, in order to never break that 16mb limit.
We also don't want to send our users an array with thousands of _ids, each time they request a parent dataset.

3-two-way referencing:
This time with the movie and actor example. So again, each movie has many actors and each actor plays in many movies and so that's a typical many to many relationship and
we usually use this two-way referencing to design many to many relationships and it works like this:
In each movie, we will keep references to all the actors that star in that movie. So a bit like in child referencing. However and at the same time in each actor,
we also keep references to all the movies that the actor played in. So movies and actors are connected in both directions and therefore the name two-way referencing and
this makes it easy to search for both movies and actors completely independently. While also making it easy to find the actors associated to each move and the movies
associated to each actor.

Summary:
The most crucial principal is:
Structure your data to match the ways that your application queries and updates data. or in other words:
Identify the questions that arise from your application's use cases first, and then model your data so that the questions can get answered in the most efficient way.
For example when I need to query movies and actors always together? or, are there scenarios where I only query movies or only actors?
That kind of questions is what your data model will be based on. In general, always favor embedding unless there is a good
reason not to embed, especially on one to a few and one to many relationships.

- A 1:TON or a MANY:MANY relationship is usually a good reason to reference instead of embedding.
- Also favor referencing when data is updated a lot and if you need to frequently access a dataset on it's own.
- Use embedding when data is mostly read but rarely updated and when two datasets being intrinsically together.
- Don't allow arrays to grow indefinitely. Therefore, if you need to normalize, use child referencing for 1:MANY relationships and parent referencing for 1:TON
relationships.
- Use two-way referencing for MANY:MANY relationships.*/
/* 150-3. Designing Our Data Model:
We learned a theory about data modeling and now let's use that theory to design the data model of our natours app and this is the most difficult part of building
an app.

The natours data model:
Let's start by all the data sets that we need in our app. Starting with tours and we already have this one implemented. Then we need some users and again we already
have a users collection in our db. So tours and users are two completely separate datasets and so we have them normalized and of course they're not gonna be
embedded.
Next we're gonna have reviews and also locations. Because most tours have a number of different locations and so that again is tet another dataset and finally,
we're gonna have bookings, but a little bit more about why that is, in a second.

users and reviews:
We have all these different datasets, not let's model the relationships that exist between them and I'm gonna start with the relationship between users and reviews and
this relationship is clearly a one-to-many relationship. Because one user can write multiple reviews, but one review can ONLY belong to one user and the parent
in this relationship is clearly the users and the child, the reviews. Because again, it's the part, so the users in this case, who can be related to many reviews, but
one review can only be related to one user.

I chose to model this relationship using parent referencing and that's because a user can write a lot of reviews and also because we might need to query
only for the reviews on their own. So the data access pattern is really crucial to take into consideration in this particular relationship.
Now about the kind of referencing that we're gonna use, it is parent referencing. So the review keeping a reference of the user, so keeping an id, basically and that
is, as you already know, because we do not want to allow a race to grow indefinitely and that might be the case if a user writes tons and tons of reviews.
Also it's nice to have the review knowing who actually wrote it and so having the user id right on the review, will allow us to do just that.

tours and reviews:
Now let's look at the relationship between tours and reviews and this one is similar. Again, it's a one-to-many relationship, where one tour can have multiple
reviews but one review can only be about one tour. So that's the way it makes sense and so we're gonna model it in the exact same way as the user-reviews relationship.
So again parent referencing, so that in the end, the reviews end up with a tour id and a user id and so then, once we query for reviews, we always know exactly.

tours and locations:
Each tour is gonna have a couple of locations. For example the park camper will stop in three or four national parks and so each of these national parks, is gonna be
one location and so each tour will have a few locations. Now following that example, one of these national parks might also be part of one of the other tours and so
this relationship is a few-to-few relationship and we called this relationships many-to-many before, but we still can also call them few-to-few or a ton ton a ton and
so I called them few-to-few , because each tour is only gonna have three, four locations, but not really like 100 and again, each of the locations can also
be part of another tour. Now, this could be a good example for implementing two-way referencing, so basically noramalizing the locations
into it's own dataset. But instead, I'm actually gonna denoramlize the locations, so to embed them into the tours and that's for multiple reasons:
1) First, because there only so few locations.
2) Also we will not really gonna access the locations on their own
3) Finally, these locations are intrinsically related to the tours. Because really without locations, there couldn't be any tours. So these datasets belong closely
together and so I chose to embed locations into tours and not create yet another collection for these.
So we will have one collection for tours, one for users and for reviews. But not for locations, again, because these will be embedded into the tours.

tours and users:
Next up, there's also a relationship between the tours and the users and that's because we're gonna have tour guides in the tours and these tour guides will actually be
users. So rememeber how we gave users a role in our mongoose schema? and the possibilities there, contained the guide and lead guide and so there's gonna be a
relationship between these types of users and the tours. Now this relationship is again a few-to-few relationship. Because one tour can have only a few users, so a few
tour guides, but at the same time, each tour guide can also be guiding a few tours and so again, there's a many-to-many relationship here,
which I simply called here few-to-few. Now about modeling this relationship, we could do it in two ways: We could use referencing or embedding and I'm gonna show you
how to implement both child referencing and embedding using mongoose thorughout this section and the argument for embedding, is that in this case,
we could then have all the information about each tour containing the information about tour guides, right on each tour document. But on the other hand,
that would then create some extra information in the database. Because we will still need to have the users as a separate collection, because we need to access them
all the time for user authentication and authorization and all that stuff.
Important: So usually, users are always an entity on their own in each database.
But we could still embed some of the users into the tours. So when a user is a tour guide, for a specific tour, we could then copy all this data
into the tour document. But also we would then have to update the user on the tour, each time that the underlying user itself changes. So let's say
that the role of a user changes from guide to lead guide and in that case, we would then have to go to the tour and also update that role information
right there on the embedded data and so that's not ideal and so we're actually also gonna then implement child referencing and so with that,
we can still keep basically the information about the tour guides on the users, but simply in a referenced form. So basically keeping the _ids there, which are
then gonna point to the users. and of course, we could also use two-way referencing, so also keeping an _id of the tour right on the user, but I think that's a bit
too much for this kind of small example. Because not all users will need an _id of the tour, because not all users are tour guides and so this relationship here is a
bit tricky to model, but I believe that in the end, child referencing is gonna be the best way to go. But still, I'm gonna also show you embedding, because I think
that's also crucial to look at.

Next up, bookings and a new booking will be created, each time that a user purchases a tour. So this is still kind of a relationship between users and tours, because
again, it's a USER who is gonna buy a tour, but we also want to store some data about that relationship itself. So in this case about the purchase itself in our
database. For example the price, or the date when the purchase happened or sth like that and so in cases like this, it's a good idea to create an extra dataset which in
this case is the bookings and so of course there will be a relationship between tours and bookings and also users and bookings and again, because the booking
connects tours with users, but kind of with an intermediate step. One tour can have many bookings, but one booking can only belong to one tour and the same thing with
users. So one user can book many tours, but one booking can only belong to one of the users and so of course we have a one-to-many relationship in both cases and
also in both cases, we're gonna use parent referencing and that means that on each booking, we're gonna keep an _id of both the tour that was purchased and also
of the user who purchased the tour and so in this case, I'm doing it this way, because I don't want to pollute the tour data with information about who actually
bought the tour. It wouldn't be really relevant to the tour data itself and the same thing with users. So we also don't want to pollute the users object
with all of the bookings that they did and so instead, again, we're gonna create like an intermidate object or an intermediate dataset that's going to stand between
users and tours, whenever they create a new purchase.

This was our data model.
Look at the <natours data model> slide.

Now we want to model the data using the mongoose library.*/
/* 151-4. Modelling Locations (Geospatial Data):
 */
