/* 148-1. Section Intro:
We're gonna model all the data for application in multiple ways and also look at how to implement our data model using advanced mongoose features.
By the end of this section, our api will be fully functioning with all routes and all resources, a complete authentication and authorization and
also all established relationships between all the data sets.
Let's get started with mongodb data modeling.*/
/* 149-2. MongoDB Data Modelling:
One of the most crucial steps in building data intensive apps, is to model all this data in mongodb.

Data ... What?
Data modeling:
Data modeling is the process of taking unstructured data generated by a real world scenario and then structure it into a logical data model in a
database and we do that according to a set of criteria which we're gonna look at in this video.
For example, let's say we want to design an online shop data model. There will be initially a ton of unstructured data that we know we need. Stuff like
products, categories, customers, orders, shopping carts, suppliers and ... . Our goal with data modeling is to then structure this data into a logical
way. Reflecting the real-world relationships that exist between some of these data sets. A bit like you can see in the slide.
There is not just one unique correct way of structuring the data. But a common process is described through 4 steps:
1) In the first step, we look at how to identify different types of relationships between data.
2) Then we're gonna understand the difference between referencing or nomalization and embedding or denormalization
3) In the most crucial step, the tutor will show us his framework for deciding whether we should embed documents or reference to other documents, based on
a couple of different factors.
4) Also we have to quickly talk about different types of referencing. Because that's crucial if that is the type of design that we choose for our data.

Recap of steps:
1) Different types of relationships between data
2) Referencing / normalization vs. embedding/denormalization
3) embedding or referencing other documents?
4) types of referencing

The way we design data, so the way we model our data, can make or break our entire application.

➡️ 1. Types of relationships between data:
There are 3 big types of relationships: one to one, one to many and many to many.
A one to one relationship between data is when one field can only have one value. So in our movie application example, one movie will only ever
have one name and this is an example of one to one relationship. But these relationships are not really that crucial in terms of data modeling.

Now the most crucial relationships are the one to many relationships and they are so crucial, that in mongodb we actually distinguish between three types
of one to many relationships: one to a few, one to many, one to a ton or to a million or sth like that.
The different here is based on the relative AMOUNT of the 'many'. An example to a 'one to a few' relationship is that one movie can win many awards but actually just
'a few'. So movie is not gonna win a thousand awards, but it can win SOME and so this is a typical 'one to few' relationship.
Important: So you see that in general, a one to many relationship means that one document can relate to many other documents.
Now this might look a bit abstract without the json data, but that's actually the purpose here. The tutor just want to show us a conecptual overview of these
different types of relationships.
Important: In a one to many relationship, one document can relate to hundreds or thousands of other documents.
For example, one movie can have thousands of reviews in our application and so this is not really a one to few, but one to many relationship.
and finally, we have the one to a ton relationship. Imagine we wanted to implement some logging functionality in our app. So basically to know exactly what's
going on on our server. These logs can then easily grow to millions of documents and so this is a typical example of a one to tons relationship and the difference
between many and a tone, is of course a bit fuzzy, but just think if sth can grow almost to infinity, then it's definitely a one to ton relationship.
So again, the one to many relationships are the most crucial ones to know. By the way, in relational databases, there is just 'one to many' without quantifying
how much that 'many' actually is. In mongodb databased though, it is an extremely crucial difference, because it's one of the factors that we're gonna use
to decide if we should denormalize or normalize data as you will look at a bit later.

Important: The last type of relationship is the many to many, where one movie can have many actors, but at the same time, one actor can play in many movies
 and so here, the relationship goes in both directions, where before in the other types, it was only in ONE direction.
For example one movie can have many reviews but one specific review, is only for that one movie and the same goes for the awards. So one specific award
like for the best actor, goes to only one movie not multiple ones. But with movies and actors, it is indeed different. So again, one movie, starts many actors,
but one actor plays many movies and so it's a many to many relationship.

Recap:
1:1 : 1 movie can only have 1 name.
1:many : 1 movie can win MANY awards
many:many : One movie can have MANY actors, but one actor can also play in MANY movies(in this case, we're processing the relationship between movie and actor).

➡️ 2. Referencing vs. embedding:
The most crucial aspect that we need to look at about mongodb databases, is referencing and embedding two datasets.
Each time we have two related datasets, we can either represent that related data, in a referenced or normalized form or in an embedded or denormalized form and
the tutor keeps using the two related terms together, like referencing and normalizing, because you will see them both being used.
In the referenced form, we keep the two related datasets and all the documents, separated. So again, all the data is nicely separated, which is
exactly what normalized means.
Continuing the movie database example from before, we would have one movie document and one actor document for each actor. Now how do we then make the
connection between movie and the actors? So that later in our app, we can show which actors played in a particular movie. Because if they are all completey
different documents, the movie has no way of knowing about the actors.
Answer: That's where the ids come in. We use the actor _ids in order to create references on the movie document. Effectively, connecting movies with actors.
So you see that in a movie document, we have an array called actors, where we stored the _ids of all the actors. So that when we request data about a certain
movie, we can easily identify it's actors.
This type of referencing is called `child referencing`. Because it's the parent, in this case, the movie, who references it's children, which in this case, the children
are the actors. So we're really creating some sort of hierarchy here.
Now there is also parent referencing.

By the way, in relational databases, all data is always represented in normalized form. But in a nosql db like mongodb, we can denormalize data into a
denormalized form, by embedding the related documents, right into the main document. So now, we have all the relevant data about actors, right inside one main movie
document without the need for separate documents, collections and _ids.
Important: So again, if we choose to denormalize or to embed our data, we will have one main document containing all the main data, as well as the related data.
and the result of this, is that our application will need to make fewer queries to the db. Because we can get all the data about movies and actors, all at the same time,
which will of course increase our performance. Now the downside here is that we can't really query the embedded data on it's own and so if that's a
requirement for the app, you would have to choose a normalized design.
In normalized form, there is an improvement in performance, when we often need to query the related data ON IT'S OWN. Because we then can just query the
data that we need and NOT always movies and actors TOGETHER. But on the other hand, when we need to query movies and actors together, we then are gonna need
many queries to the db. So first the query for the movie and then from there, we will also need a query for the actors and that is of worst, for performance.

So when designing you db, this is the kind of stuff that you need to keep in mind.

Note: We could begin our though process with denormalized data and then come to the conclusion that it's best to normalize the data.
So when thinking about our data model, this way of organizing data works in both ways.

Now how do we decide if we should normalize or denoramlize the data?

➡️ 3. When to embed and when to reference? A practical framework:
When we have two related datasets, we have to decide if we're gonna embed the datasets or if we're gonna keep them separated and reference from one dataset to the
other. There is a decision framework where we use three criteria to take that decision.
1) We look at the type of relationships that exist between datasets
2) We try to determine the data access pattern of the dataset that we want to either embed or reference(means to analyze how often data is read and
   written in that dataset)
3) We look at data closeness, which means how much the data is really related and how we want to query the data from db.

Recap:
1) Relationship type:
How two datasets are related to each other

2) Data access patterns:
How often data is read and written. Read/write ratio

3) Data closensess:
How "much" the data is related. how we want to query

To take the decision, we need to COMBINE all of these three criteria and not just use one of them in isolation. For example, just because
criteria number one says to embed, it doesn't mean that we don't need to look at the other two criteria.

About first criteria:
Important: Usually when we have a one to few relationship, we will always embed the related dataset into the main dataset.
 In a one to many relationship, things are a bit more fuzzy. So it's okay to either embed or reference. In that case, we will have to decide according
to the other two criteria .
On a one to a ton or a many to many relationship, we usually always reference the data. That's because if we did embed in this case, we could quickly create
way too large documents, even potentially surpassing the maximum of 16 megabyte and so the solution for that is of course referencing or normalizing the data and
as a quick example, let's say that in our movie db example, we have around 100 images associated to each movie. So we could say it's a one to many relationship.
But are we gonna embed the datasets or should we rather reference them there?
Well, we don't really know. So let's take a look at the other two criteria.

About second criteria:
The second one is about data access patterns, which is just a fancy description for evalutating whether a certain dataset is mostly written to, or mostly read from.
Important: If the dataset that we're deciding about, is mostly read and the data is not updated a lot, then we should probably embed that dataset. So a high
 read/write ratio just means that there is a lot more reading than writing and again, a dataset like that, is a good candidate for embedding.
 and the reason for this is that by embedding, we only need one trip to the database per query. While for referencing, we need two trips.
 So if we embed data that is read a lot, in each query we save one trip to the database, making the entire process way more performant.
So I think that our movie image example would actually be a good candidate for embedding. Because once the 100 images are saved to the database,
they are not really updated anymore, because there is not really anything to update about an image. So it's all about reading and therefore based on this
criteria, we would embed the image documents.
Important: On the other hand, if our data is updated a lot, then we should consider referencing or normalizing the data. That's because it's more
 work for the database engine to update an embedded document than a more simple standalone document and since our main goal is performance,
 we just normalize the dataset.
In our example, let's say each movie has many reviews and each review can be marked as helpful by the user. So each time someone clicks on 'this review was helpful' in
our app, we need to update the corresponding document and this means that the data can change all the time and so this is a great candidate for normalizing. Again because
we don't want to be querying the movies all the time, if all we really wanna update is the reviews by marking them as helpful.


About third criteria(data closeness):
Data closeness is just like a measure for how much the data is related. So if the two datasets really intrinsically belong together, then they should
probably be embedded into one another.
In our example, all users can have many email addresses on their account and since they are so intrinsically connected to the user, there is no doubt emails should
be embedded into the document.
Important: Now if we frequently need to query both of datasets on their own, then that's a very good reason to normalize
 the data into two separate datasets, even if they are closely related. So imagine that in our app we have a quiz where users have to identify a movie based on
 images. This means that we're gonna query a lot of images on their own. So without necessarily querying for the movies themselves and so if we apply this
 third criteria, we come to the conclusion that we should normalize the image dataset. Because again if we implement this quiz functionality, images are gonna
 be queried on their own all the time.
So all of this shows that we should really look at all the three criteria together rather than just one of them in isolation. Because that might lead to
less optimal decisions and I say less optimal instead of wrong, because they are not really any completely right or completely wrong ways of modeling our data.
There are no hard rules, these are just like guidelines that you can follow to find the probably most correct way of structuring your data.

➡️ 4. Types of referencing:
Let's say that we have chosen to noramlize our datasets. So in other words, to reference data, then after that, we still have to choose
between three different types of referencing: child referencing, parent referencing and two-way referencing.
1- The first type is child referencing. For example in error logging example, we could potentially have millions of locked documents. So in child referencing,
we keep refrences to the related child documents, in a parent document and they're usually stored in an array. For example, each log has an _id and then in
the app document, there is that array with all of those _ids. However the problem here is that that array of _ids can become very large if there are lots of
children and this is an anti-pattern in mongodb. So sth that we should avoid at all costs. Also child referencing makes it so, that parents and children are
very tightly coupled, which is not always ideal, but that's exactly why we have parent referencing.

2- In parent referencing, it actually works the other way around. Here, in each child document, we keep a reference to the parent element. Therefore, the name
'parent referencing'. In the slide's example, the app _id is 23 and so in each log there is the `app` field with the 23 _id in it. So that the child always knows it's
parent and so in this case, the parent actually knows nothing about the children!!! Not who they are and not how many they are. So they are way more isolated
and more standalone and that can sometimes beneficial.

Which of these two types is better for this data relationship? and remember how I said that there could be millions of logs and so let's suppose
there is two million log documents. In a case of child referencing, that would mean that there are two million _id references in the app document.
Now also remember how I said that there is a 16 megabyte limit on documents. So if we kept adding and adding these child ids into the array on the parent,
then we would quickly hit that 16 megabytes limit that each Bson document can hold. Simply because that array will grow so much.
So that's not really gonna work.
On the other hand, with parent referencing, that problem is not gonna happen. We will simply have two million log documents just like before but each of them
holds _id of it's parent. But there is no array that will grow indefinitely and therefore parent referencing will be the best solution here.

Important: So the conclusion of all this, is that in general, child referencing is best used for one to a few relationships, where we know BEFOREHAND that the
 array of child documents won't grow that much. On the other hand, parent referencing is best used for one to many and one to a ton relationships like our example.

One of the most crucial principals of mongodb data modeling is that array should never be allowed to grow indefintely, in order to never break that 16mb limit.
We also don't want to send our users an array with thousands of _ids, each time they request a parent dataset.

3-two-way referencing:
This time with the movie and actor example. So again, each movie has many actors and each actor plays in many movies and so that's a typical many to many relationship and
we usually use this two-way referencing to design many to many relationships and it works like this:
In each movie, we will keep references to all the actors that star in that movie. So a bit like in child referencing. However and at the same time in each actor,
we also keep references to all the movies that the actor played in. So movies and actors are connected in both directions and therefore the name two-way referencing and
this makes it easy to search for both movies and actors completely independently. While also making it easy to find the actors associated to each move and the movies
associated to each actor.

Summary:
The most crucial principal is:
Structure your data to match the ways that your application queries and updates data. or in other words:
Identify the questions that arise from your application's use cases first, and then model your data so that the questions can get answered in the most efficient way.
For example when I need to query movies and actors always together? or, are there scenarios where I only query movies or only actors?
That kind of questions is what your data model will be based on. In general, always favor embedding unless there is a good
reason not to embed, especially on one to a few and one to many relationships.

- A 1:TON or a MANY:MANY relationship is usually a good reason to reference instead of embedding.
- Also favor referencing when data is updated a lot and if you need to frequently access a dataset on it's own.
- Use embedding when data is mostly read but rarely updated and when two datasets being intrinsically together.
- Don't allow arrays to grow indefinitely. Therefore, if you need to normalize, use child referencing for 1:MANY relationships and parent referencing for 1:TON
relationships.
- Use two-way referencing for MANY:MANY relationships.*/
/* 150-3. Designing Our Data Model:
We learned a theory about data modeling and now let's use that theory to design the data model of our natours app and this is the most difficult part of building
an app.

The natours data model:
Let's start by all the data sets that we need in our app. Starting with tours and we already have this one implemented. Then we need some users and again we already
have a users collection in our db. So tours and users are two completely separate datasets and so we have them normalized and of course they're not gonna be
embedded.
Next we're gonna have reviews and also locations. Because most tours have a number of different locations and so that again is tet another dataset and finally,
we're gonna have bookings, but a little bit more about why that is, in a second.

users and reviews:
We have all these different datasets, not let's model the relationships that exist between them and I'm gonna start with the relationship between users and reviews and
this relationship is clearly a one-to-many relationship. Because one user can write multiple reviews, but one review can ONLY belong to one user and the parent
in this relationship is clearly the users and the child, the reviews. Because again, it's the part, so the users in this case, who can be related to many reviews, but
one review can only be related to one user.

I chose to model this relationship using parent referencing and that's because a user can write a lot of reviews and also because we might need to query
only for the reviews on their own. So the data access pattern is really crucial to take into consideration in this particular relationship.
Now about the kind of referencing that we're gonna use, it is parent referencing. So the review keeping a reference of the user, so keeping an id, basically and that
is, as you already know, because we do not want to allow a race to grow indefinitely and that might be the case if a user writes tons and tons of reviews.
Also it's nice to have the review knowing who actually wrote it and so having the user id right on the review, will allow us to do just that.

tours and reviews:
Now let's look at the relationship between tours and reviews and this one is similar. Again, it's a one-to-many relationship, where one tour can have multiple
reviews but one review can only be about one tour. So that's the way it makes sense and so we're gonna model it in the exact same way as the user-reviews relationship.
So again parent referencing, so that in the end, the reviews end up with a tour id and a user id and so then, once we query for reviews, we always know exactly.

tours and locations:
Each tour is gonna have a couple of locations. For example the park camper will stop in three or four national parks and so each of these national parks, is gonna be
one location and so each tour will have a few locations. Now following that example, one of these national parks might also be part of one of the other tours and so
this relationship is a few-to-few relationship and we called this relationships many-to-many before, but we still can also call them few-to-few or a ton ton a ton and
so I called them few-to-few , because each tour is only gonna have three, four locations, but not really like 100 and again, each of the locations can also
be part of another tour. Now, this could be a good example for implementing two-way referencing, so basically noramalizing the locations
into it's own dataset. But instead, I'm actually gonna denoramlize the locations, so to embed them into the tours and that's for multiple reasons:
1) First, because there only so few locations.
2) Also we will not really gonna access the locations on their own
3) Finally, these locations are intrinsically related to the tours. Because really without locations, there couldn't be any tours. So these datasets belong closely
together and so I chose to embed locations into tours and not create yet another collection for these.
So we will have one collection for tours, one for users and for reviews. But not for locations, again, because these will be embedded into the tours.

tours and users:
Next up, there's also a relationship between the tours and the users and that's because we're gonna have tour guides in the tours and these tour guides will actually be
users. So rememeber how we gave users a role in our mongoose schema? and the possibilities there, contained the guide and lead guide and so there's gonna be a
relationship between these types of users and the tours. Now this relationship is again a few-to-few relationship. Because one tour can have only a few users, so a few
tour guides, but at the same time, each tour guide can also be guiding a few tours and so again, there's a many-to-many relationship here,
which I simply called here few-to-few. Now about modeling this relationship, we could do it in two ways: We could use referencing or embedding and I'm gonna show you
how to implement both child referencing and embedding using mongoose thorughout this section and the argument for embedding, is that in this case,
we could then have all the information about each tour containing the information about tour guides, right on each tour document. But on the other hand,
that would then create some extra information in the database. Because we will still need to have the users as a separate collection, because we need to access them
all the time for user authentication and authorization and all that stuff.
Important: So usually, users are always an entity on their own in each database.
But we could still embed some of the users into the tours. So when a user is a tour guide, for a specific tour, we could then copy all this data
into the tour document. But also we would then have to update the user on the tour, each time that the underlying user itself changes. So let's say
that the role of a user changes from guide to lead guide and in that case, we would then have to go to the tour and also update that role information
right there on the embedded data and so that's not ideal and so we're actually also gonna then implement child referencing and so with that,
we can still keep basically the information about the tour guides on the users, but simply in a referenced form. So basically keeping the _ids there, which are
then gonna point to the users. and of course, we could also use two-way referencing, so also keeping an _id of the tour right on the user, but I think that's a bit
too much for this kind of small example. Because not all users will need an _id of the tour, because not all users are tour guides and so this relationship here is a
bit tricky to model, but I believe that in the end, child referencing is gonna be the best way to go. But still, I'm gonna also show you embedding, because I think
that's also crucial to look at.

Next up, bookings and a new booking will be created, each time that a user purchases a tour. So this is still kind of a relationship between users and tours, because
again, it's a USER who is gonna buy a tour, but we also want to store some data about that relationship itself. So in this case about the purchase itself in our
database. For example the price, or the date when the purchase happened or sth like that and so in cases like this, it's a good idea to create an extra dataset which in
this case is the bookings and so of course there will be a relationship between tours and bookings and also users and bookings and again, because the booking
connects tours with users, but kind of with an intermediate step. One tour can have many bookings, but one booking can only belong to one tour and the same thing with
users. So one user can book many tours, but one booking can only belong to one of the users and so of course we have a one-to-many relationship in both cases and
also in both cases, we're gonna use parent referencing and that means that on each booking, we're gonna keep an _id of both the tour that was purchased and also
of the user who purchased the tour and so in this case, I'm doing it this way, because I don't want to pollute the tour data with information about who actually
bought the tour. It wouldn't be really relevant to the tour data itself and the same thing with users. So we also don't want to pollute the users object
with all of the bookings that they did and so instead, again, we're gonna create like an intermediate object or an intermediate dataset that's going to stand between
users and tours, whenever they create a new purchase.

This was our data model.
Look at the <natours data model> slide.

Now we want to model the data using the mongoose library.*/
/* 151-4. Modelling Locations (Geospatial Data):
We're gonna look at geospatial data in mongodb.
Remember that our location data will be embedded into the tours and so we're gonna declare everything that is related to locations, in our tour model.

Mongodb supports geospatial data out of the box and geospatial data is data that describes places on earth using longitude and latitude coordinates.
So we can describe simple points, or we can also describe more complex geometries, like lines or even polygons or even multi-polygons. So really everything is
possible with geospatial data in mongodb.

Mongodb uses a special data format called GeoJSON in order to specify geospatial data.

The object that we specify for startLocation field, this time, is not for the schema type options as we have to for example for
secretTour field. So the object we specify for secretTour is for the schema type options, but now, the object we specify for startLocation, is REALLY an embedded object,
so inside of that object we can specify a couple of properties and in order for that object to be recognized as geospatial JSON, we need the type and the
coordinates properties.
Important: So we want type and coordinates and now, each of these two sub-fields is then gonna get it's own schema type options.
So there it's a bit nested. So we have the type schema type options and we also need schema type options for coordinates, just like we have in for example the
createdAt field, with the difference that the type and coordinates fields are sub-fields.

We can specify multiple geometries in mongodb and the default one is always 'Point', but we can also specify polygons or lines or other geometries like that.
But for startLocation, it should be Point and so let's actually make that the ony possible option by specifying the enum property which is an array of all the
possible options that that field can take and in this case we only want it to be 'Point'.

We specified [Number] for coordinates field, which means that we expect an array of numbers and this array is the coordinates of the point with the longtitude first
and only second, the latitude and so that's a bit counterintuitive, because usually it works the other way around, but in GeoJson, that's just how it works.
So if you were to go, for example to google maps in order to get your coordinates, then you will see first the latitude and then the longitude.

The latitude is the horizontal position measured in degrees starting from the equator.
The equator is zero degrees and in north pole, it's 90degrees and then the longitude, is just the same thing but vertically.
So it's the position starting from a meridian.

We also want to specify a property for the address and a description of that startLocation.

Learn: In order to specify geospatial data with mongodb, we need to create a new OBJECT, such as we did with startLocation field and that object then needs to have
 at least two field names: coordinates which is of type an array of numbers and then the type field which should be of type string and should be either Point or
 some other of those other geometries.
We can add some more fields to this geospatial object such as we did with startLocation, that has address and description fields.

Remember we said we were gonna embed all the locations into the tour documents, but right now, the startLocation is not really a document itself. It's really
just an object describing a certain point on earth. But in order to really create new documents and then embed them into another document,
we actually need to create an array. So it's similar to what we already have there, but it needs to be an array and that's what we're gonna do with
our locations field.
So the locations field should be an array and in that array is where I'm gonna specify the object such as I did it before in startLocation. So now it's quite the same
as before.
So the type for geospatial data needs to be string and the default needs to be 'Point' and then, it cannot be anything but 'Point'. So enum: ['Point'].
Again, we need coordinates as an array of numbers.
The `day` field will be the day of the tour, in which people will go to this location.

Now if we wanted to make it simpler, we could delete the startLocation all together and then simply define the first location as the startLocation and set it to
day number zero. But I decided it's nice to also have the startLocation as a separate field.

So this is how you create embedded documents. Remember we always need to use that array that we used for locations field as it's value and so by specifying
an array of objects, this will then create brand new documents inside of the parent document, which is in this case, the tour.

Now in order to create some locations, I'm going to import all our original data. So instead of creating new tours,
I will delete the ones we have and then import the complete data. So in dev-data folder, remember that before we imported tours-simple.json , but we also have
tours.json and that then actually has the locations and startLocation.

The objects inside the locations array, each one gets it's own _id and so those really are documents and not just simple objects.

So go to import-dev-data.js and replace fs.readFileSync(`${__dirname}/tour-simple.json`, 'utf-8') with fs.readFileSync(`${__dirname}/tour.json`, 'utf-8') .

Now remember we need first to delete and then to import. So in console, run: node ./dev-data/data/import-dev-data.js --delete
and then run but with the --import option.
Remember to run your server in background to do these.

In each step, you can check the tours collection in compass to ensure everything worked fine.

In locations array, we have objects that each has it's ObjectId as the value for it's _id field and so again, this is proof that we have now created,
embedded, or de-normalized datasets.
Important: So datasets that have a really close relationship with the tours data and so that's why we chose to really make it part
 of the tours instead of creating it's own collection(so just for locations).

We will use this a bit later in this section, once we start to create some special geospatial queries and with geospatial queries, we can do amazing stuff, like
finding locations that are closest to certain points, or find all locations inside a certain radius or a certain sphere.

This was how we can create embedded datasets.*/
/* 152-5. Modelling Tour Guides Embedding:
We said that we could either embed or reference the tour guide data. In this vid, we're gonna look at how we could implement embedding
tour guide documents into a tour document. So we're gonna embed user docs into tour docs and then in the next video, we will see
how we can reference users instead of embedding.

The idea here is that when creating a new tour document, the user will simply add an array of user ids and we will then get the corresponding user docs, based on those
ids and add them to our tour documents. So in other words, we embed them into our tour.
So guids field will be of type Array.

In postman and in create new tour req, we specify an array of _ids(user ids, like the ones we have in get all users req) for guide property and from the get all users
route, then add it to guides array in `create new tour` req.

This is how we're gonna create a new tour with two guides and once we then save that tour(we're creating a tour!), we will then, behind the scenes,
retrieve the two user documents corresponding to those _ids that we put in the guides array property and in our model file, the best place of doing that,
is a pre-save middleware. So that will happen automatically behind the scenes, each time that a new tour is saved.
In the function we pass to pre save middleware as the second arg, we get this.guides as an input and remember this is gonna be an array of all the user _ids
and so we will loop through them using a map() and then in each iteration, get the user document for the current _id .
The elements inside this.guides is _ids of users.

Important: The function we pass to map() would be an async function, but this causes a problem. Because the map() method will assign the result of each iteration
 to the new element in the guides array and now we have an async function passed to map() and as you know, that returns a promise and so right now, the
 guides array is basically an array full of promises.
So let's call the resulting array, guidesPromises instead of guides and so we now need to run all of these promises, basically at the same time. So we can use
Promise.all() . We assigned the reuslt of await Promise.all() to this.guides, so we override that simple array of _ids with an array of user docs.

We need to use Promise.all() because the result of all of that function that we passed to map() , is a promise, so that guidesPromises is gonna be an array full of
promises, which we then run by awaiting Promise.all() .

Let's test this, by creating a new tour with multiple _ids in it's guides field.

Now in db, the guides array has multiple complete guide documents(users that are now guides of that created tour) and not just an array of _ids.

So this is how we could implement embedding for this tour guides example.

Now the code that we wrote in the new pre save middleware, of course only works for creating new docs, not for updating them. So now, we would have to go
ahead and implement this same logic also for updates. However the tutor is not gonna do that, because remember from the video where we modeled our data, that there
are actually some drawbacks of embedding this data in this case. For example, imagine that a tour guide updates his email address, or they change their role
from guide to lead guide. Each time one of these changes would happen, then you'd have to check if a tour has that user as a guide, and if so, then update the tour as well
and that's really a lot of work and we're not gonna go in that direction.

In this particular situation, we will instead of embedding, use referencing and we talked about the reasons behind it before.
*/
/* 153-6. Modelling Tour Guides Child Referencing
We embedded users into tours in the last video and also talked about the drawbacks of that approach in our specific situation and in this vid,
let's connect tours and users not by embedding but instead by a reference and to start, comment the pre save middleware that we wrote in last vid.
That pre save middleware is responsible for performing the embedding.

Now in guides field, the idea is that tours and users will always remain completely separate entities in our database. So all we save on a certain tour document,
is the ids of the users that are the tour guides for that specific tour. Then, when we query the tour, we want to automatically get access to the tour guides., but again,
without them being actually saved on the tour document itself and that exactly is referencing.
Now let's implement referencing using mongoose.

In the guides field, specify an array, so just like before with the locations and so that again means that those will be some sub-documents, so embedded docs.

With mongoose.Schema.ObjectId , we expect the type of each of the elements in the guides array to be a mongodb id.

We have to put the type inside an object, just like any other schema type definition, because that's all this really is.
After type property, we need to specify the reference and that is where the magic happens behind the scenes, because there, now we say that the reference should be
'User'.
This is how we establish references between different data sets in mongoose and for this, we actually do not even need to have the user to be imported into that document.
So you can comment out the const User = require('./userModel'); line(we had that for the previous lecture but we can comment it out, because what we just did
there(ref: 'User') is still gonna work).

Let's now create a new tour(you can delete the last created test tour with the delete tour route and then create that again).

Now create a new tour and just like before, all we pass into the guides property of request body is an array of _ids ,
but this time, we specified that an ObjectId is exactly what we expect(the ids we pass to guides must be of type ObjectId, but behind the scenes,
it's also referenced to the user). When we now create that tour, it will only contain those _ids that we specified and not the user corresponding to the _ids.

In the next vid, we will take care of displaying the user data in the output using a process called `populating`.*/
/* 154-7. Populating Tour Guides:
Let's now use a process called populate, in order to get access to the referenced tour guides, whenever we query for a certain tour.
In the last vid, we created a reference to the user, in the guides field in our tour model and now we're gonna use populate, in order to
replace the fields that we referenced with the actual related data and the result of that, will look as if the data has always been embedded, when in fact, as we know,
it is in a completely different collection.

The populate process always happens in a query.
In tour controller and in getTour function and in there, Tour.findById(req.params.id); is where we build our query and now, all we need to do, is to add
the populate to the query. So call .populate() and then pass the name of the field which we want to populate.
If you think about it, the name populate, makes sense. Because we want to populate, so basically to fill up the field called guides in our model.
Again, that guides field only contains the reference and with populate9) , we're then gonna fill it up with the actual data and again, only in the query and not in the
actual database.

Now let's take a look at result. Now the guides field in output, contains the full user documents and not only their _ids, but in db, only their _id is stored.
So the elements in guides array that we had in the guides array, have now been populated with the actual data.

But currently in get all tours route, you see the guides array still has the values that are ACTUALLY in the database(only the _ids).

Note: In populate() , we replace the ids with the actual data. But in get all tours route that step doesn't happen, because we didn't implement the populate()
in the get all tours route handler.

A trick that we can do with the populate function, which is to actually also just select the certain fields. For example we're not interested in that _v property that
we have in results and also not in passwordChangedAt field. So that's not the kind of data that we want about our tour guides. For that, in populate() ,
we can instead of just passing in the string, we can create an object of options which the path property is the name of the field we want to replace and then
as usual, we can use select property and then a minus with the field names in select property.
So instead of:
const tour = await Tour.findById(req.params.id).populate('guides');
we say:
const tour = await Tour.findById(req.params.id).populate({
  path: 'guides',
  select: '-__v -passwordChangedAt'
});

Now those fields are not shown in the result when getting a tour, so we only get the data that we're interested in.

So the populate() is a fundamental tool for working with data in mongoose and especially of course when there are relationships between data,

Behind the scenes, using populate() will still actually create a new query and so this might affect your performance. Of course if you only do it once or twice
and in a kind of small app, then that small hit on performance is no big deal at all. But in a huge app, with tons of populate()s all over the place,
then that might indeed have some kind of effect. Really it makes sense, because how else would mongoose be able to get data about tours and users at the same time?
It NEEDS to create a new query basically in order to be able to create this connection.
Currently, this don't work when we use get all the tours route, so there we still simply get the _ids of the tour guides and not the referenced user data.
One solution would basically be to copy the code we have in getTour, and paste it in getAllTours route handler, but duplicate code is never a good idea.
The better way is query middleware. So go to tourModel and write a pre middleware that will run when it's gonna work with everything that starts with 'find'.
Important: We do this in query middleware, because this is the kind of middleware that is going to run each time there is a query.

We called populate() on `this` keyword in the query middleware, because remember that in query middleware, `this` always points to the current query and so now
all of the queries will then automatically populate the guides field with the referenced user. So get rid of that code in getTour route handler.
So now we're doing it in the query middleware, instead of doing it in multiple places in the controller.
Important: So this is a trick in case that you always want to populate all your documents(so we use a query middleware).

We're just testing and put users with the role of not guide or lead-guide as guides in tours.

This is how populating works which is a crucial tool in your toolbax.

Recap: This is a two-step process:
First you create a reference to another model by using the ref property in the array field that you have which would contain the docs in the output.
So with ref: '<name of model>', you effectively create the relationship between those two datasets.
Then in the second step, you populate that field which in this case is the guides field, using the populate() method.
*/
/* 155-8. Modelling Reviews Parent Referencing:
 */
