/* 148-1. Section Intro:
We're gonna model all the data for application in multiple ways and also look at how to implement our data model using advanced mongoose features.
By the end of this section, our api will be fully functioning with all routes and all resources, a complete authentication and authorization and
also all established relationships between all the data sets.
Let's get started with mongodb data modeling.*/
/* 149-2. MongoDB Data Modelling:
One of the most crucial steps in building data intensive apps, is to model all this data in mongodb.

Data ... What?
Data modeling:
Data modeling is the process of taking unstructured data generated by a real world scenario and then structure it into a logical data model in a
database and we do that according to a set of criteria which we're gonna look at in this video.
For example, let's say we want to design an online shop data model. There will be initially a ton of unstructured data that we know we need. Stuff like
products, categories, customers, orders, shopping carts, suppliers and ... . Our goal with data modeling is to then structure this data into a logical
way. Reflecting the real-world relationships that exist between some of these data sets. A bit like you can see in the slide.
There is not just one unique correct way of structuring the data. But a common process is described through 4 steps:
1) In the first step, we look at how to identify different types of relationships between data.
2) Then we're gonna understand the difference between referencing or nomalization and embedding or denormalization
3) In the most crucial step, the tutor will show us his framework for deciding whether we should embed documents or reference to other documents, based on
a couple of different factors.
4) Also we have to quickly talk about different types of referencing. Because that's crucial if that is the type of design that we choose for our data.

Recap of steps:
1) Different types of relationships between data
2) Referencing / normalization vs. embedding/denormalization
3) embedding or referencing other documents?
4) types of referencing

The way we design data, so the way we model our data, can make or break our entire application.

➡️ 1. Types of relationships between data:
There are 3 big types of relationships: one to one, one to many and many to many.
A one to one relationship between data is when one field can only have one value. So in our movie application example, one movie will only ever
have one name and this is an example of one to one relationship. But these relationships are not really that crucial in terms of data modeling.

Now the most crucial relationships are the one to many relationships and they are so crucial, that in mongodb we actually distinguish between three types
of one to many relationships: one to a few, one to many, one to a ton or to a million or sth like that.
The different here is based on the relative AMOUNT of the 'many'. An example to a 'one to a few' relationship is that one movie can win many awards but actually just
'a few'. So movie is not gonna win a thousand awards, but it can win SOME and so this is a typical 'one to few' relationship.
Important: So you see that in general, a one to many relationship means that one document can relate to many other documents.
Now this might look a bit abstract without the json data, but that's actually the purpose here. The tutor just want to show us a conecptual overview of these
different types of relationships.
Important: In a one to many relationship, one document can relate to hundreds or thousands of other documents.
For example, one movie can have thousands of reviews in our application and so this is not really a one to few, but one to many relationship.
and finally, we have the one to a ton relationship. Imagine we wanted to implement some logging functionality in our app. So basically to know exactly what's
going on on our server. These logs can then easily grow to millions of documents and so this is a typical example of a one to tons relationship and the difference
between many and a tone, is of course a bit fuzzy, but just think if sth can grow almost to infinity, then it's definitely a one to ton relationship.
So again, the one to many relationships are the most crucial ones to know. By the way, in relational databases, there is just 'one to many' without quantifying
how much that 'many' actually is. In mongodb databased though, it is an extremely crucial difference, because it's one of the factors that we're gonna use
to decide if we should denormalize or normalize data as you will look at a bit later.

Important: The last type of relationship is the many to many, where one movie can have many actors, but at the same time, one actor can play in many movies
 and so here, the relationship goes in both directions, where before in the other types, it was only in ONE direction.
For example one movie can have many reviews but one specific review, is only for that one movie and the same goes for the awards. So one specific award
like for the best actor, goes to only one movie not multiple ones. But with movies and actors, it is indeed different. So again, one movie, starts many actors,
but one actor plays many movies and so it's a many to many relationship.

Recap:
1:1 : 1 movie can only have 1 name.
1:many : 1 movie can win MANY awards
many:many : One movie can have MANY actors, but one actor can also play in MANY movies(in this case, we're processing the relationship between movie and actor).

➡️ 2. Referencing vs. embedding:
The most crucial aspect that we need to look at about mongodb databases, is referencing and embedding two datasets.
Each time we have two related datasets, we can either represent that related data, in a referenced or normalized form or in an embedded or denormalized form and
the tutor keeps using the two related terms together, like referencing and normalizing, because you will see them both being used.
In the referenced form, we keep the two related datasets and all the documents, separated. So again, all the data is nicely separated, which is
exactly what normalized means.
Continuing the movie database example from before, we would have one movie document and one actor document for each actor. Now how do we then make the
connection between movie and the actors? So that later in our app, we can show which actors played in a particular movie. Because if they are all completey
different documents, the movie has no way of knowing about the actors.
Answer: That's where the ids come in. We use the actor _ids in order to create references on the movie document. Effectively, connecting movies with actors.
So you see that in a movie document, we have an array called actors, where we stored the _ids of all the actors. So that when we request data about a certain
movie, we can easily identify it's actors.
This type of referencing is called `child referencing`. Because it's the parent, in this case, the movie, who references it's children, which in this case, the children
are the actors. So we're really creating some sort of hierarchy here.
Now there is also parent referencing.

By the way, in relational databases, all data is always represented in normalized form. But in a nosql db like mongodb, we can denormalize data into a
denormalized form, by embedding the related documents, right into the main document. So now, we have all the relevant data about actors, right inside one main movie
document without the need for separate documents, collections and _ids.
Important: So again, if we choose to denormalize or to embed our data, we will have one main document containing all the main data, as well as the related data.
and the result of this, is that our application will need to make fewer queries to the db. Because we can get all the data about movies and actors, all at the same time,
which will of course increase our performance. Now the downside here is that we can't really query the embedded data on it's own and so if that's a
requirement for the app, you would have to choose a normalized design.
In normalized form, there is an improvement in performance, when we often need to query the related data ON IT'S OWN. Because we then can just query the
data that we need and NOT always movies and actors TOGETHER. But on the other hand, when we need to query movies and actors together, we then are gonna need
many queries to the db. So first the query for the movie and then from there, we will also need a query for the actors and that is of worst, for performance.

So when designing you db, this is the kind of stuff that you need to keep in mind.

Note: We could begin our though process with denormalized data and then come to the conclusion that it's best to normalize the data.
So when thinking about our data model, this way of organizing data works in both ways.

Now how do we decide if we should normalize or denoramlize the data?

➡️ 3. When to embed and when to reference? A practical framework:
When we have two related datasets, we have to decide if we're gonna embed the datasets or if we're gonna keep them separated and reference from one dataset to the
other. There is a decision framework where we use three criteria to take that decision.
1) We look at the type of relationships that exist between datasets
2) We try to determine the data access pattern of the dataset that we want to either embed or reference(means to analyze how often data is read and
   written in that dataset)
3) We look at data closeness, which means how much the data is really related and how we want to query the data from db.

Recap:
1) Relationship type:
How two datasets are related to each other

2) Data access patterns:
How often data is read and written. Read/write ratio

3) Data closensess:
How "much" the data is related. how we want to query

To take the decision, we need to COMBINE all of these three criteria and not just use one of them in isolation. For example, just because
criteria number one says to embed, it doesn't mean that we don't need to look at the other two criteria.

About first criteria:
Important: Usually when we have a one to few relationship, we will always embed the related dataset into the main dataset.
 In a one to many relationship, things are a bit more fuzzy. So it's okay to either embed or reference. In that case, we will have to decide according
to the other two criteria .
On a one to a ton or a many to many relationship, we usually always reference the data. That's because if we did embed in this case, we could quickly create
way too large documents, even potentially surpassing the maximum of 16 megabyte and so the solution for that is of course referencing or normalizing the data and
as a quick example, let's say that in our movie db example, we have around 100 images associated to each movie. So we could say it's a one to many relationship.
But are we gonna embed the datasets or should we rather reference them there?
Well, we don't really know. So let's take a look at the other two criteria.

About second criteria:
The second one is about data access patterns, which is just a fancy description for evalutating whether a certain dataset is mostly written to, or mostly read from.
Important: If the dataset that we're deciding about, is mostly read and the data is not updated a lot, then we should probably embed that dataset. So a high
 read/write ratio just means that there is a lot more reading than writing and again, a dataset like that, is a good candidate for embedding.
 and the reason for this is that by embedding, we only need one trip to the database per query. While for referencing, we need two trips.
 So if we embed data that is read a lot, in each query we save one trip to the database, making the entire process way more performant.
So I think that our movie image example would actually be a good candidate for embedding. Because once the 100 images are saved to the database,
they are not really updated anymore, because there is not really anything to update about an image. So it's all about reading and therefore based on this
criteria, we would embed the image documents.
Important: On the other hand, if our data is updated a lot, then we should consider referencing or normalizing the data. That's because it's more
 work for the database engine to update an embedded document than a more simple standalone document and since our main goal is performance,
 we just normalize the dataset.
In our example, let's say each movie has many reviews and each review can be marked as helpful by the user. So each time someone clicks on 'this review was helpful' in
our app, we need to update the corresponding document and this means that the data can change all the time and so this is a great candidate for normalizing. Again because
we don't want to be querying the movies all the time, if all we really wanna update is the reviews by marking them as helpful.


About third criteria(data closeness):
Data closeness is just like a measure for how much the data is related. So if the two datasets really intrinsically belong together, then they should
probably be embedded into one another.
In our example, all users can have many email addresses on their account and since they are so intrinsically connected to the user, there is no doubt emails should
be embedded into the document.
Important: Now if we frequently need to query both of datasets on their own, then that's a very good reason to normalize
 the data into two separate datasets, even if they are closely related. So imagine that in our app we have a quiz where users have to identify a movie based on
 images. This means that we're gonna query a lot of images on their own. So without necessarily querying for the movies themselves and so if we apply this
 third criteria, we come to the conclusion that we should normalize the image dataset. Because again if we implement this quiz functionality, images are gonna
 be queried on their own all the time.
So all of this shows that we should really look at all the three criteria together rather than just one of them in isolation. Because that might lead to
less optimal decisions and I say less optimal instead of wrong, because they are not really any completely right or completely wrong ways of modeling our data.
There are no hard rules, these are just like guidelines that you can follow to find the probably most correct way of structuring your data.

➡️ 4. Types of referencing:
Let's say that we have chosen to noramlize our datasets. So in other words, to reference data, then after that, we still have to choose
between three different types of referencing: child referencing, parent referencing and two-way referencing.
1- The first type is child referencing. For example in error logging example, we could potentially have millions of locked documents. So in child referencing,
we keep refrences to the related child documents, in a parent document and they're usually stored in an array. For example, each log has an _id and then in
the app document, there is that array with all of those _ids. However the problem here is that that array of _ids can become very large if there are lots of
children and this is an anti-pattern in mongodb. So sth that we should avoid at all costs. Also child referencing makes it so, that parents and children are
very tightly coupled, which is not always ideal, but that's exactly why we have parent referencing.

2- In parent referencing, it actually works the other way around. Here, in each child document, we keep a reference to the parent element. Therefore, the name
'parent referencing'. In the slide's example, the app _id is 23 and so in each log there is the `app` field with the 23 _id in it. So that the child always knows it's
parent and so in this case, the parent actually knows nothing about the children!!! Not who they are and not how many they are. So they are way more isolated
and more standalone and that can sometimes beneficial.

Which of these two types is better for this data relationship? and remember how I said that there could be millions of logs and so let's suppose
there is two million log documents. In a case of child referencing, that would mean that there are two million _id references in the app document.
Now also remember how I said that there is a 16 megabyte limit on documents. So if we kept adding and adding these child ids into the array on the parent,
then we would quickly hit that 16 megabytes limit that each Bson document can hold. Simply because that array will grow so much.
So that's not really gonna work.
On the other hand, with parent referencing, that problem is not gonna happen. We will simply have two million log documents just like before but each of them
holds _id of it's parent. But there is no array that will grow indefinitely and therefore parent referencing will be the best solution here.

Important: So the conclusion of all this, is that in general, child referencing is best used for one to a few relationships, where we know BEFOREHAND that the
 array of child documents won't grow that much. On the other hand, parent referencing is best used for one to many and one to a ton relationships like our example.

One of the most crucial principals of mongodb data modeling is that array should never be allowed to grow indefintely, in order to never break that 16mb limit.
We also don't want to send our users an array with thousands of _ids, each time they request a parent dataset.

3-two-way referencing:
This time with the movie and actor example. So again, each movie has many actors and each actor plays in many movies and so that's a typical many to many relationship and
we usually use this two-way referencing to design many to many relationships and it works like this:
In each movie, we will keep references to all the actors that star in that movie. So a bit like in child referencing. However and at the same time in each actor,
we also keep references to all the movies that the actor played in. So movies and actors are connected in both directions and therefore the name two-way referencing and
this makes it easy to search for both movies and actors completely independently. While also making it easy to find the actors associated to each move and the movies
associated to each actor.

Summary:
The most crucial principal is:
Structure your data to match the ways that your application queries and updates data. or in other words:
Identify the questions that arise from your application's use cases first, and then model your data so that the questions can get answered in the most efficient way.
For example when I need to query movies and actors always together? or, are there scenarios where I only query movies or only actors?
That kind of questions is what your data model will be based on. In general, always favor embedding unless there is a good
reason not to embed, especially on one to a few and one to many relationships.

- A 1:TON or a MANY:MANY relationship is usually a good reason to reference instead of embedding.
- Also favor referencing when data is updated a lot and if you need to frequently access a dataset on it's own.
- Use embedding when data is mostly read but rarely updated and when two datasets being intrinsically together.
- Don't allow arrays to grow indefinitely. Therefore, if you need to normalize, use child referencing for 1:MANY relationships and parent referencing for 1:TON
relationships.
- Use two-way referencing for MANY:MANY relationships.*/
/* 150-3. Designing Our Data Model:
We learned a theory about data modeling and now let's use that theory to design the data model of our natours app and this is the most difficult part of building
an app.

The natours data model:
Let's start by all the data sets that we need in our app. Starting with tours and we already have this one implemented. Then we need some users and again we already
have a users collection in our db. So tours and users are two completely separate datasets and so we have them normalized and of course they're not gonna be
embedded.
Next we're gonna have reviews and also locations. Because most tours have a number of different locations and so that again is tet another dataset and finally,
we're gonna have bookings, but a little bit more about why that is, in a second.

users and reviews:
We have all these different datasets, not let's model the relationships that exist between them and I'm gonna start with the relationship between users and reviews and
this relationship is clearly a one-to-many relationship. Because one user can write multiple reviews, but one review can ONLY belong to one user and the parent
in this relationship is clearly the users and the child, the reviews. Because again, it's the part, so the users in this case, who can be related to many reviews, but
one review can only be related to one user.

I chose to model this relationship using parent referencing and that's because a user can write a lot of reviews and also because we might need to query
only for the reviews on their own. So the data access pattern is really crucial to take into consideration in this particular relationship.
Now about the kind of referencing that we're gonna use, it is parent referencing. So the review keeping a reference of the user, so keeping an id, basically and that
is, as you already know, because we do not want to allow a race to grow indefinitely and that might be the case if a user writes tons and tons of reviews.
Also it's nice to have the review knowing who actually wrote it and so having the user id right on the review, will allow us to do just that.

tours and reviews:
Now let's look at the relationship between tours and reviews and this one is similar. Again, it's a one-to-many relationship, where one tour can have multiple
reviews but one review can only be about one tour. So that's the way it makes sense and so we're gonna model it in the exact same way as the user-reviews relationship.
So again parent referencing, so that in the end, the reviews end up with a tour id and a user id and so then, once we query for reviews, we always know exactly.

tours and locations:
Each tour is gonna have a couple of locations. For example the park camper will stop in three or four national parks and so each of these national parks, is gonna be
one location and so each tour will have a few locations. Now following that example, one of these national parks might also be part of one of the other tours and so
this relationship is a few-to-few relationship and we called this relationships many-to-many before, but we still can also call them few-to-few or a ton ton a ton and
so I called them few-to-few , because each tour is only gonna have three, four locations, but not really like 100 and again, each of the locations can also
be part of another tour. Now, this could be a good example for implementing two-way referencing, so basically noramalizing the locations
into it's own dataset. But instead, I'm actually gonna denoramlize the locations, so to embed them into the tours and that's for multiple reasons:
1) First, because there only so few locations.
2) Also we will not really gonna access the locations on their own
3) Finally, these locations are intrinsically related to the tours. Because really without locations, there couldn't be any tours. So these datasets belong closely
together and so I chose to embed locations into tours and not create yet another collection for these.
So we will have one collection for tours, one for users and for reviews. But not for locations, again, because these will be embedded into the tours.

tours and users:
Next up, there's also a relationship between the tours and the users and that's because we're gonna have tour guides in the tours and these tour guides will actually be
users. So rememeber how we gave users a role in our mongoose schema? and the possibilities there, contained the guide and lead guide and so there's gonna be a
relationship between these types of users and the tours. Now this relationship is again a few-to-few relationship. Because one tour can have only a few users, so a few
tour guides, but at the same time, each tour guide can also be guiding a few tours and so again, there's a many-to-many relationship here,
which I simply called here few-to-few. Now about modeling this relationship, we could do it in two ways: We could use referencing or embedding and I'm gonna show you
how to implement both child referencing and embedding using mongoose thorughout this section and the argument for embedding, is that in this case,
we could then have all the information about each tour containing the information about tour guides, right on each tour document. But on the other hand,
that would then create some extra information in the database. Because we will still need to have the users as a separate collection, because we need to access them
all the time for user authentication and authorization and all that stuff.
Important: So usually, users are always an entity on their own in each database.
But we could still embed some of the users into the tours. So when a user is a tour guide, for a specific tour, we could then copy all this data
into the tour document. But also we would then have to update the user on the tour, each time that the underlying user itself changes. So let's say
that the role of a user changes from guide to lead guide and in that case, we would then have to go to the tour and also update that role information
right there on the embedded data and so that's not ideal and so we're actually also gonna then implement child referencing and so with that,
we can still keep basically the information about the tour guides on the users, but simply in a referenced form. So basically keeping the _ids there, which are
then gonna point to the users. and of course, we could also use two-way referencing, so also keeping an _id of the tour right on the user, but I think that's a bit
too much for this kind of small example. Because not all users will need an _id of the tour, because not all users are tour guides and so this relationship here is a
bit tricky to model, but I believe that in the end, child referencing is gonna be the best way to go. But still, I'm gonna also show you embedding, because I think
that's also crucial to look at.

Next up, bookings and a new booking will be created, each time that a user purchases a tour. So this is still kind of a relationship between users and tours, because
again, it's a USER who is gonna buy a tour, but we also want to store some data about that relationship itself. So in this case about the purchase itself in our
database. For example the price, or the date when the purchase happened or sth like that and so in cases like this, it's a good idea to create an extra dataset which in
this case is the bookings and so of course there will be a relationship between tours and bookings and also users and bookings and again, because the booking
connects tours with users, but kind of with an intermediate step. One tour can have many bookings, but one booking can only belong to one tour and the same thing with
users. So one user can book many tours, but one booking can only belong to one of the users and so of course we have a one-to-many relationship in both cases and
also in both cases, we're gonna use parent referencing and that means that on each booking, we're gonna keep an _id of both the tour that was purchased and also
of the user who purchased the tour and so in this case, I'm doing it this way, because I don't want to pollute the tour data with information about who actually
bought the tour. It wouldn't be really relevant to the tour data itself and the same thing with users. So we also don't want to pollute the users object
with all of the bookings that they did and so instead, again, we're gonna create like an intermediate object or an intermediate dataset that's going to stand between
users and tours, whenever they create a new purchase.

This was our data model.
Look at the <natours data model> slide.

Now we want to model the data using the mongoose library.*/
/* 151-4. Modelling Locations (Geospatial Data):
We're gonna look at geospatial data in mongodb.
Remember that our location data will be embedded into the tours and so we're gonna declare everything that is related to locations, in our tour model.

Mongodb supports geospatial data out of the box and geospatial data is data that describes places on earth using longitude and latitude coordinates.
So we can describe simple points, or we can also describe more complex geometries, like lines or even polygons or even multi-polygons. So really everything is
possible with geospatial data in mongodb.

Mongodb uses a special data format called GeoJSON in order to specify geospatial data.

The object that we specify for startLocation field, this time, is not for the schema type options as we have to for example for
secretTour field. So the object we specify for secretTour is for the schema type options, but now, the object we specify for startLocation, is REALLY an embedded object,
so inside of that object we can specify a couple of properties and in order for that object to be recognized as geospatial JSON, we need the type and the
coordinates properties.
Important: So we want type and coordinates and now, each of these two sub-fields is then gonna get it's own schema type options.
So there it's a bit nested. So we have the type schema type options and we also need schema type options for coordinates, just like we have in for example the
createdAt field, with the difference that the type and coordinates fields are sub-fields.

We can specify multiple geometries in mongodb and the default one is always 'Point', but we can also specify polygons or lines or other geometries like that.
But for startLocation, it should be Point and so let's actually make that the ony possible option by specifying the enum property which is an array of all the
possible options that that field can take and in this case we only want it to be 'Point'.

We specified [Number] for coordinates field, which means that we expect an array of numbers and this array is the coordinates of the point with the longtitude first
and only second, the latitude and so that's a bit counterintuitive, because usually it works the other way around, but in GeoJson, that's just how it works.
So if you were to go, for example to google maps in order to get your coordinates, then you will see first the latitude and then the longitude.

The latitude is the horizontal position measured in degrees starting from the equator.
The equator is zero degrees and in north pole, it's 90degrees and then the longitude, is just the same thing but vertically.
So it's the position starting from a meridian.

We also want to specify a property for the address and a description of that startLocation.

Learn: In order to specify geospatial data with mongodb, we need to create a new OBJECT, such as we did with startLocation field and that object then needs to have
 at least two field names: coordinates which is of type an array of numbers and then the type field which should be of type string and should be either Point or
 some other of those other geometries.
We can add some more fields to this geospatial object such as we did with startLocation, that has address and description fields.

Remember we said we were gonna embed all the locations into the tour documents, but right now, the startLocation is not really a document itself. It's really
just an object describing a certain point on earth. But in order to really create new documents and then embed them into another document,
we actually need to create an array. So it's similar to what we already have there, but it needs to be an array and that's what we're gonna do with
our locations field.
So the locations field should be an array and in that array is where I'm gonna specify the object such as I did it before in startLocation. So now it's quite the same
as before.
So the type for geospatial data needs to be string and the default needs to be 'Point' and then, it cannot be anything but 'Point'. So enum: ['Point'].
Again, we need coordinates as an array of numbers.
The `day` field will be the day of the tour, in which people will go to this location.

Now if we wanted to make it simpler, we could delete the startLocation all together and then simply define the first location as the startLocation and set it to
day number zero. But I decided it's nice to also have the startLocation as a separate field.

So this is how you create embedded documents. Remember we always need to use that array that we used for locations field as it's value and so by specifying
an array of objects, this will then create brand new documents inside of the parent document, which is in this case, the tour.

Now in order to create some locations, I'm going to import all our original data. So instead of creating new tours,
I will delete the ones we have and then import the complete data. So in dev-data folder, remember that before we imported tours-simple.json , but we also have
tours.json and that then actually has the locations and startLocation.

The objects inside the locations array, each one gets it's own _id and so those really are documents and not just simple objects.

So go to import-dev-data.js and replace fs.readFileSync(`${__dirname}/tour-simple.json`, 'utf-8') with fs.readFileSync(`${__dirname}/tour.json`, 'utf-8') .

Now remember we need first to delete and then to import. So in console, run: node ./dev-data/data/import-dev-data.js --delete
and then run but with the --import option.
Remember to run your server in background to do these.

In each step, you can check the tours collection in compass to ensure everything worked fine.

In locations array, we have objects that each has it's ObjectId as the value for it's _id field and so again, this is proof that we have now created,
embedded, or de-normalized datasets.
Important: So datasets that have a really close relationship with the tours data and so that's why we chose to really make it part
 of the tours instead of creating it's own collection(so just for locations).

We will use this a bit later in this section, once we start to create some special geospatial queries and with geospatial queries, we can do amazing stuff, like
finding locations that are closest to certain points, or find all locations inside a certain radius or a certain sphere.

This was how we can create embedded datasets.*/
/* 152-5. Modelling Tour Guides Embedding:
We said that we could either embed or reference the tour guide data. In this vid, we're gonna look at how we could implement embedding
tour guide documents into a tour document. So we're gonna embed user docs into tour docs and then in the next video, we will see
how we can reference users instead of embedding.

The idea here is that when creating a new tour document, the user will simply add an array of user ids and we will then get the corresponding user docs, based on those
ids and add them to our tour documents. So in other words, we embed them into our tour.
So guids field will be of type Array.

In postman and in create new tour req, we specify an array of _ids(user ids, like the ones we have in get all users req) for guide property and from the get all users
route, then add it to guides array in `create new tour` req.

This is how we're gonna create a new tour with two guides and once we then save that tour(we're creating a tour!), we will then, behind the scenes,
retrieve the two user documents corresponding to those _ids that we put in the guides array property and in our model file, the best place of doing that,
is a pre-save middleware. So that will happen automatically behind the scenes, each time that a new tour is saved.
In the function we pass to pre save middleware as the second arg, we get this.guides as an input and remember this is gonna be an array of all the user _ids
and so we will loop through them using a map() and then in each iteration, get the user document for the current _id .
The elements inside this.guides is _ids of users.

Important: The function we pass to map() would be an async function, but this causes a problem. Because the map() method will assign the result of each iteration
 to the new element in the guides array and now we have an async function passed to map() and as you know, that returns a promise and so right now, the
 guides array is basically an array full of promises.
So let's call the resulting array, guidesPromises instead of guides and so we now need to run all of these promises, basically at the same time. So we can use
Promise.all() . We assigned the reuslt of await Promise.all() to this.guides, so we override that simple array of _ids with an array of user docs.

We need to use Promise.all() because the result of all of that function that we passed to map() , is a promise, so that guidesPromises is gonna be an array full of
promises, which we then run by awaiting Promise.all() .

Let's test this, by creating a new tour with multiple _ids in it's guides field.

Now in db, the guides array has multiple complete guide documents(users that are now guides of that created tour) and not just an array of _ids.

So this is how we could implement embedding for this tour guides example.

Now the code that we wrote in the new pre save middleware, of course only works for creating new docs, not for updating them. So now, we would have to go
ahead and implement this same logic also for updates. However the tutor is not gonna do that, because remember from the video where we modeled our data, that there
are actually some drawbacks of embedding this data in this case. For example, imagine that a tour guide updates his email address, or they change their role
from guide to lead guide. Each time one of these changes would happen, then you'd have to check if a tour has that user as a guide, and if so, then update the tour as well
and that's really a lot of work and we're not gonna go in that direction.

In this particular situation, we will instead of embedding, use referencing and we talked about the reasons behind it before.
*/
/* 153-6. Modelling Tour Guides Child Referencing
We embedded users into tours in the last video and also talked about the drawbacks of that approach in our specific situation and in this vid,
let's connect tours and users not by embedding but instead by a reference and to start, comment the pre save middleware that we wrote in last vid.
That pre save middleware is responsible for performing the embedding.

Now in guides field, the idea is that tours and users will always remain completely separate entities in our database. So all we save on a certain tour document,
is the ids of the users that are the tour guides for that specific tour. Then, when we query the tour, we want to automatically get access to the tour guides., but again,
without them being actually saved on the tour document itself and that exactly is referencing.
Now let's implement referencing using mongoose.

In the guides field, specify an array, so just like before with the locations and so that again means that those will be some sub-documents, so embedded docs.

With mongoose.Schema.ObjectId , we expect the type of each of the elements in the guides array to be a mongodb id.

We have to put the type inside an object, just like any other schema type definition, because that's all this really is.
After type property, we need to specify the reference and that is where the magic happens behind the scenes, because there, now we say that the reference should be
'User'.
This is how we establish references between different data sets in mongoose and for this, we actually do not even need to have the user to be imported into that document.
So you can comment out the const User = require('./userModel'); line(we had that for the previous lecture but we can comment it out, because what we just did
there(ref: 'User') is still gonna work).

Let's now create a new tour(you can delete the last created test tour with the delete tour route and then create that again).

Now create a new tour and just like before, all we pass into the guides property of request body is an array of _ids ,
but this time, we specified that an ObjectId is exactly what we expect(the ids we pass to guides must be of type ObjectId, but behind the scenes,
it's also referenced to the user). When we now create that tour, it will only contain those _ids that we specified and not the user corresponding to the _ids.

In the next vid, we will take care of displaying the user data in the output using a process called `populating`.*/
/* 154-7. Populating Tour Guides:
Let's now use a process called populate, in order to get access to the referenced tour guides, whenever we query for a certain tour.
In the last vid, we created a reference to the user, in the guides field in our tour model and now we're gonna use populate, in order to
replace the fields that we referenced with the actual related data and the result of that, will look as if the data has always been embedded, when in fact, as we know,
it is in a completely different collection.

The populate process always happens in a query.
In tour controller and in getTour function and in there, Tour.findById(req.params.id); is where we build our query and now, all we need to do, is to add
the populate to the query. So call .populate() and then pass the name of the field which we want to populate.
If you think about it, the name populate, makes sense. Because we want to populate, so basically to fill up the field called guides in our model.
Again, that guides field only contains the reference and with populate9) , we're then gonna fill it up with the actual data and again, only in the query and not in the
actual database.

Now let's take a look at result. Now the guides field in output, contains the full user documents and not only their _ids, but in db, only their _id is stored.
So the elements in guides array that we had in the guides array, have now been populated with the actual data.

But currently in get all tours route, you see the guides array still has the values that are ACTUALLY in the database(only the _ids).

Note: In populate() , we replace the ids with the actual data. But in get all tours route that step doesn't happen, because we didn't implement the populate()
in the get all tours route handler.

A trick that we can do with the populate function, which is to actually also just select the certain fields. For example we're not interested in that _v property that
we have in results and also not in passwordChangedAt field. So that's not the kind of data that we want about our tour guides. For that, in populate() ,
we can instead of just passing in the string, we can create an object of options which the path property is the name of the field we want to replace and then
as usual, we can use select property and then a minus with the field names in select property.
So instead of:
const tour = await Tour.findById(req.params.id).populate('guides');
we say:
const tour = await Tour.findById(req.params.id).populate({
  path: 'guides',
  select: '-__v -passwordChangedAt'
});

Now those fields are not shown in the result when getting a tour, so we only get the data that we're interested in.

So the populate() is a fundamental tool for working with data in mongoose and especially of course when there are relationships between data,

Behind the scenes, using populate() will still actually create a new query and so this might affect your performance. Of course if you only do it once or twice
and in a kind of small app, then that small hit on performance is no big deal at all. But in a huge app, with tons of populate()s all over the place,
then that might indeed have some kind of effect. Really it makes sense, because how else would mongoose be able to get data about tours and users at the same time?
It NEEDS to create a new query basically in order to be able to create this connection.
Currently, this don't work when we use get all the tours route, so there we still simply get the _ids of the tour guides and not the referenced user data.
One solution would basically be to copy the code we have in getTour, and paste it in getAllTours route handler, but duplicate code is never a good idea.
The better way is query middleware. So go to tourModel and write a pre middleware that will run when it's gonna work with everything that starts with 'find'.
Important: We do this in query middleware, because this is the kind of middleware that is going to run each time there is a query.

We called populate() on `this` keyword in the query middleware, because remember that in query middleware, `this` always points to the current query and so now
all of the queries will then automatically populate the guides field with the referenced user. So get rid of that code in getTour route handler.
So now we're doing it in the query middleware, instead of doing it in multiple places in the controller.
Important: So this is a trick in case that you always want to populate all your documents(so we use a query middleware).

We're just testing and put users with the role of not guide or lead-guide as guides in tours.

This is how populating works which is a crucial tool in your toolbox.

Recap: This is a two-step process:
First you create a reference to another model by using the ref property in the array field that you have which would contain the docs in the output.
So with ref: '<name of model>', you effectively create the relationship between those two datasets.
Then in the second step, you populate that field which in this case is the guides field, using the populate() method.*/
/* 155-8. Modelling Reviews Parent Referencing:
Let's continue to translate the data model that we established, at the beginning of the section, into some actual code and so this time, we're gonna implement the
reviews model.
The first step is to create a new file in the models folder and call it reviewModel.js .
In that model, we want the text for the review, a rating, createdAt, a reference to the tour that that review belongs to and also to the user
who wrote that review. So basically two parent references there.

The rating field would be between 1 and 5, so min is 1 and max is 5.
The min and max properties are validators that work only for numbers.

Now let's create the model and export it. So: const review = mongoose.model(<model name>, <schema>);

Then export the model by using module.exports .

Now comes the reference part: A review of course needs to belong to a tour and it also needs an author. So that's again what we specified
in our data modeling lecture. We were gonna implement parent referencing in this case. Because both the tour and the user are in a sense the parents of that
data set(review data set) and we decided to do it this way, because we don't want potentially huge arrays in the parent elements. So we should not design our
app, thinking that there will only be a few reviews, only to then come back to it after some time and find out that our assumptions were wrong and now
we need to rebuild our entire data model.
Important: So in many situations, when we do not really know how much our arrays will grow, then it's just best to opt for parent
 referencing and that's exactly what we're doing here, when we're referencing tour and user.
So now, create a field called `tour` and do according to source code.
Now each review document now knows exactly what tour it belongs to. While the tour of course, doesn't now initially what reviews and how many reviews there are, but that
is a problem that we will solve a bit later.
Next, when there is a review, we not only want to know what tour it belongs to, but also who wrote this review.
So create a field called user.
We make it required, because a review really cannot work without an author.

Let's add some options to the schema, where we make it so that virtual properties also show up in json and object outputs(we did that before in tour schema).
Those options are:
{
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
}
and all this does is to make sure that when we have a virtual property, so a field that is not stored in the database, but calculated using some other value, we want
that to also show up whenever there is an output.

In the next video, we will use the schema in order to create some new reviews.*/
/* 156-9. Creating and Getting Reviews:
We're gonna continue implementing the reviews resource and this time by implementing an endpoint for getting all reviews and also for creating new reviews.
Create reviewController.js .

We're building a lot of duplicate code. Because for example the current code in getAllReviews looks exactly the same as it looks for the users and for the tours,
we're gonna fix this.

When we say: await Review.create(req.body) in createReview, we create a new doc with all the data coming in from the body and if there are any fields on the
body that are not in the review schema, then they will be ignored and so that's why it's safe to do it like this, when creating a new resource.

201 status code is for 'created'.

Now create a new route file named reviewRoutes.js . There, create a router by using express.Router() .
There, when we say: router.route('/') , it's basically route of the reviews, because remember how in the next step we're going to mount
that router on '/api/v1/reviews' . After exporting the router from reviewRoutes.js , go to app.js and there, we mount the new router on a new path which is
'/api/v1/reviews'. So again, that new reviewsRouter is a middleware that we mount upon that path*('/api/v1/reviews'). So whenever there is a request with a url that
starts like '/api/v1/reviews' , then that reviewsRouter middleware function will be called and so that is then our router, and in there, we have just '/' as route(so
just the root basically), will then be that '/api/v1/reviews', so just like we did it before with the other two resources.

We only want the authenticated users to be able to POST reviews and also only users that are actually regular users, so not administrators and also not tour guides.

The protect middleware will make it so that we protect that route to only be accessed by users who are authenticated and then, in the next step, we say that we want
to restrict that route to only users with the role of 'user'.

Recap:
First off, we have a model which allow us to create new documents. Then we have our controller functions defined in our controller to get all reviews and ... , then
we used those controller functions or handler functions to create some new routes, for example we created a route for gettung reviewsd and for posting reviews
and just like before, we did this in a mini sub-application which is just for reviews and so that's why we created our new router which then we imported into our
main app(app.js) and mounted it on /api/v1/reviews url where we want to access everything related to reviews.

Now test the reviews resource routes.
For creating a review, use an _id of a tour that you currently have, also we want the _id of the user posting the review and we can get that
from 'get all users' route. Now keep in mind that this user who is writing a review for a tour, needs to be logged in and so a bit later,
we will then automatically get the user id from the user that's already logged in. Remember we can do that because the protect middleware will put the user on the
request object, but for now, I wanted to keep it simple and so with the current implementation, we actually NEED to provide the user's id as well. But still,
we need to log in as a regular user, because we protected this route for creating a review.
So now login with the user that you want to create a review as him, in postman.

Note: If a user is no longer active(his active property is set to false), he doesn't show up in results, but it's email can not be taken yet by another user.

Now in Authorization tab of the new request for creating a review, choose "Bearer Token".

We don't need to pass the token to server in Authorization tab of get all reviews request.

Now in response of get all reviews, we only see the user's id and the tour's id. How do we make it so that we actually see the user anad the tour data in response,
instead of simply the _ids?
We need to use the populate() , in the next video.*/
/* 157-10. Populating Reviews:
Let's populate the reviews with both the user and the tour data and so just like we did on the tour, let's now make it so, that both the tour and the user
will be automatically populated each time there is a query for a review.

When you want to populate two fields, you need to call populate() twice, so once for each of the fields.

In reviewModel, implement a pre-find middleware and we do that on the schema and we use a regex to match strings which start with 'find' and this is going to
work for find, findOne and all the other findOne.. methods that are available in mongoose. There, we need to call this.populate() on the current query.
We passed the options object to .populate() there, because I only want to select a couple of fields and not the entire tour and also not the entire user.
By specifying `path: 'tour'`, it means that the tour field which has the exact same name, is then going to be the one that's populated based on a tour model, well because
that's what we specfied in the definition of that field, which we have: ref: 'Tour', so the reference is to a model called Tour and it's in that collection where
mongoose is then going to look for documents with the id that we specified.
So we want the tour, but then we only want the tour name and nothing else, so pass this to populate():
{path: 'tour', select: 'name'}.

If we want to populate MULTIPLE fields, we need to call populate() again. For example, with the first populate() , the query is populated with the tours and now
we need to populate it again, this time, with the user.

We didn't select the email of user in that second populate(), because let's say that someone hits the api to get all the reviews, but then we don't want to
leak all the details about the users posting these reviews to the client. So no one should really be able to know the private data about the reviewers, like
emails and ... . So again, we only leak or in other words, we only send relevant data about the user, and in this case, it's the name and the photo.

If we now hit our get all reviews endpoint, the tour and the user should be populated instead of us just seeing the _ids there.

Currently we do not see the photo property in the response, because we never specified any photo for any of our users yet.

Keep in mind that this(using populate() twice) is gonna add some extra queries and in this case, it's actually two queries. Because behind the scenes,
mongoose will actually have to query both the tours and also the users in order to find the matching document. If you look at the Time in postman, you can
see how much it took like 260ms. If you comment the pre find middleware that we just wrote in reviewModel, you can get for example 157ms and if you now again put
that code back, you get a little bit longer.*/
/* 158-11. Virtual Populate Tours and Reviews:
Let's continue with a new and pretty advanced mongoose feature called 'virtual populate'. At this point, we have populated the reviews with the tour
and the user in that pre find middleware in reviewModel and so right now, when we query for reviews, we get access to that information, however, that still
leaves one problem unsolved. How are we going to access reviews on the tours? So the other way around? Let's say that I query for a specific tour and then,
how will I get access to all the reviews for that tour? and this problem arises here because we did parent referencing on the reviews. So basically having the reviews
pointing to the tours and not the tours pointing to the reviews and so as we said in the beginnning of the section, in this case, the parent does not
really know about it's children and so in this example, the tour does not know about it's reviews and sometimes that's okay, but in this case, we actually want the tour
to know about all the reviews that it's got.
Now in order to solve this, with what we know at this point, we could have two solutions:
1) Manually query for reviews each time that we query for tours. But it would be a bit cumbersome doing it manually like this.
2) To also do child referencing on the tours. So keep an array of all the review _ids on each tour document. Then, all we would have to do is to populate that
array, but, we actually already ruled out doing this right in the beginning, because we do not want to store that array of review _ids, that could then grow
indefinitely in our database and that's exactly why we picked parent referencing in the first place.

However there is a great solution for this and that's because mongoose actually offers us a very nice solution for this problem with a pretty advanced feature
called 'virtual populate'.
With virtual populate, we can actually populate the tour with reviews. So in other words, we can get access to all the reviews for a certain tour, BUT, without
keeping this array of _ids on the tour. So think of virtual populate like a way of keeping that array of review _ids on a tour, but without actually persisting
it to the database and so that then solves the problem that we have with child referencing. So it's a bit like virtual fields, but with populate().

What I describe would be in theory, to have, on our tour model, we would add a field called `reviews`(and connect it with 'review'):
reviews: {
  type: mongoose.Schema.ObjectId,
  ref: 'Review'
}
So the above field would be how we would implement child referencing. So the tour, referencing reviews. But again, we do not want to do it and instead,
we're going to implement virtual populate.

For this, on tourSchema, call .virtual() (so just like virtual field), then we type in the name of virtual field and let's call this virtual field, `reviews` and then
pass in an object of some options and the first option is the name of the model that we want to reference and so that works just like with the normal referencing and
in this case, that model name is Review and now, we need to specify the name of the fields, in order to connect the two datasets and this is for tutor, the most
complicated part of implementing virtual populate.
There, we need to specify two fields: The foreign field and the local field.
Important: ForeignField is the name of the field in the other model, in this case, in the Review model, where the reference to the current model is stored and that is
 in this case, the tour field.
So again, in our Review model, we have a field called tour and that is where the _id of the tour is being stored and so that's why to the foreignField, we specify that
name of that field in order to connect those two models and now we need to do the same for the current model. So we need to say where that _id is actually
stored here, in that current Tour model, so use the localField option.
So again, the localField which in this case is `_id`(the field in the local model), is called `tour` in the foreign model(Review model).

This is how we connect those two models together.

Now, with this setup, we can use populate() just like we did before and what we want to do now, is to go ahead and populate() the tour when twe only
get one single tour, so in postman, it is the request of 'Get Tour'.
So now when we get a tour, we now want to populate the reviews and currently, it's set to null, but the virtual field is actually already there with the reviews,
but it's null at this point because we didn't yet populate it and again, we ONLY want to populate it, in the Get one tour and not in Get All tours. Because
that would be a bit too much information to send down to the client when they get all the tours.
Also when we're getting all the tours, that's usually to build like an overview page and in that case, we usually do not need to access all the reviews.
We only need that when we are really displaying just one tour, so it makes sense to only do this populate on 'Get One Tour'.
Now let's do that populate right in the tourController where we have getTour handler and pass the name of the field that we want to populate to populate() .

Now test the get one tour route.
So we get the related reviews and it means that our virtual populate is working.

Now you might start to see that this is creating kind of a problem. Because this is basically creating a chain of populates and that's not ideal at all.
So we have the tour being populated with reviews, but then the reviews ALSO get populated with the `tour` again and also with the `user` and then also the
`tour` is also getting populated with the `guides`, which in the result that I get, the guides was an empty array(because there were no guides
for that tour, but if there were, then we would have yet another populate()), but you get the idea!
So here we have a chain of three populate()s and so for performance, it's not ideal, especially with the tour. Because we have the tour populated with reviews
(which makes a reviews property that has an array as value in the tour)and then in the reviews, we again have the data about the tour(look at the tour property
in each object in review array) and so that doesn't make sense at all.
So it's kind of a mess now.

The solution that we're gonna use, is to turn off populating the reviews with the tours. So we do not need that tour data on each review.
In this case, that's a good solution, but of course, again in your case, it will always depend on how your application works in your specific case.
But in this app, it's more logical to really have the reviews avaialable on tours and it's not that crucial having the tour available on the review.
So let's turn that populate off in reviewModel and in it's pre find middleware and now we should only see the _id of the tour in each object in reviews property.
With this of course we still do parent referencing. So we still keep a reference to the tours, but we simply do not populate() it and again, because
we don't always need that data right there.

RECAP: We started doing only parent referencing on the review, but that made it so that on the tours, we had no access to it's corresponding reviews and the easiest
fix for that would be to also do child referencing on the tours, but the problem with that would be that we do not actually want to keep an array of all the
child documents on the parent document. Because again, we don't want to allow arrays to grow indefinitely. So instead of doing that,
we implemented virtual populates like the one we defined with tourSchema.virtual('review', {...}); and that allows us to do the exact same thing, so keeping a
reference to all the child documents on the parent document, but without actually PERSISTING that information to the database and so then,
after having this virtual populate set up, all we needed to do is to use populate() just like we did before, with the real references(we did this in getTour handler)
and then finally we also turned off one of the populates that we had on the review in it's pre find middleware in reviewSchema, where we populated the tour id, because
that was creating kind of an inefficient chain of populates and that's of course sth that we don't want.

Now we want to create nested routes.*/
/* 159-12. Implementing Simple Nested Routes:
How in practice, we want to create a new review?
Up until this point, when creating new reviews, we always manually passed the tour _id and the user _id into the request body and then created the review
from there and that's ok during development, but of course, that's not how a review will be created in the real world.
In the real world, the user _id should ideally come from the currently logged in user and the tour _id should come from the current tour and that should ideally
be encoded right in the route, so in the url. So when submitting a POST request for a new review, we will want to submit that to a url like:
'/tour/:tourId/reviews'.
So now just like this, we have the tour id in the url and the user id will come from the currently logged in user and so what we see in that previous url, is now
a so-called nested route and they make a lot of sense when there is a clear parent-child relationshiop between resources and that is clearly the case here.
Important: So reviews is clearly a child of tours and so this nested route means to access the reviews resource on the tours resource when we have:
 '/tour/:tourId/reviews' and in the same way, we will also want to access reviews from a certain tour in the same way, so let's say a GET req for:
 '/tour/:tourId/reviews' and this would ideally get us all the reviews for this tour with that tourId.

We could go even further and also specify the id of the review:  '/tour/:tourId/reviews/:reviewId'. In this case, we would get review with the :reviewId on the tour with
:tourId.
This is what nested routes are all about and this is a way more easier way of reading and understanding how the api works for our api users.
It's way easier than messing around with query strings and all that stuff like that. Also it really shows how there is this clear relationship between
these resources. So again, reviews and tours in this case.

Let's implement this. Since the route starts with tours, it will be redirected to our tour router and so we're going to have to imeplement this functionality,
at least for now, in the tour router, even though that seems a bit counter-intuitive, since we're in fact, dealing with reviews. But again, for now, let's imeplement
it like this. Go to tourRoutes and since, we're going to use reviews there, import reviewController.

We want to have a route like: /tour/:tourId/reviews .
Now that /tour is where we MOUNTED that router and so we do not have to repeat it in tourRoutes.js .
Since we're dealing with different resources in that path, it's better to name :id as :tourId .
Again, it is a bit weird and counter-intuitive to call the reviewController in the tourRoutes, but again, for now, we need to do it like this, because the route
starts with 'tour' and so it's the router in tourRoutes that will get activated, but we're gonna fix that.

Now in reviewController's createReview, we say if there is no req.body.tour , so basically if we didn't specify the tourId and the body then,
we want to define that as the one coming from the url.

Note: We get req.user from protect middleware.

With this, we make it so that the user can still specify manually the tour and the user id.
So what we're doing there is to define them when they are not in req.body .

Now if you login as a user that has a role as user, create a review for a tour and as the result, we get the final review with both the tour and the user
correctly defined.

Create a new folder for this new request in postman and call it Tours/Reviews and name that req: Create New Review On Tour.

Currently we have defined a review route in the tour router and we're gonna fix that.*/
/* 160-13. Nested Routes with Express:
We're gonna use a special advanced express feature.
In last vid, we implemented a nested POST route which is:
router.route('/:tourId/reviews').post(...) in tourRoutes file.
and this means that the review route is kind of WITHIN the tour route and again, because reviews belong to tours in a sense and this is a very common
thing to do in API design.
Now the problem with this implementation is that it is a bit messy and it's because we put a route fir creating a review in the tour router, simply because a
route starts with /tour , so that's a bit confusing and what's also confusing is that we have sth very similar to this
router.route('/:tourId/reviews').post(authController.protect, authController.restrictTo('user'), reviewController.createReview) which is
in tourRoutes.js , also in our reviewRoutes and that thing is: ....post(authController.protect, authController.restrictTo('user'), reviewController.createReview) .
So when we create a new review without the nested route, that piece of code inside .post() is exactly the same in both places. So besides this being confusing,
we also have duplicate code which we would have to maintain in two separate places in case we wanted to change anything and that's a bad practice.

Let's fix this using an advanced express feature called mergeParams.
First off remove that code from tourRoutes which doesn't really belong to the tour router. Then import the reviewRouter into the tourRouter!
Now we say: router.use('/:tourId/reviews', reviewRouter) which it means: this tour router should use the review router in case it ever encounters a
route like '/:tourId/reviews'.

A router itself is really just a middleware and so we can use the use() method on it and then say that for that specific route like in this case,
'/:tourId/reviews', we want to use the reviewRouter instead and so this is again mounting a router.
In app.js we did exactly this, we used .use() on app , then a route and then the router.
So whenever it finds a url like '/:tourId/reviews' on tourRouter, use the reviewRouter.
So now, if we have a url like '/:tourId/reviews' , it will start by getting into the tourRouter which we specified it in app.js (because it starts
with /tours, so it's rerouted into the tourRouter), then when it reaches the tourRouter, it will match the '/:tourId/reviews' url and then it will
again be routed into the reviewRouter and like this, we have the tourRouter and the reviewRouter nicely separated and decoupled from one another.

But now there's still one piece missing, because right now, that reviewRouter that we specified in router.use() in tourRoutes, doesn't get access tp
that :tourId parameter which is in url and so now we need to enable the reviewRouter to get access to that parameter as well and this is where magical
mergeParams.
In reviewRoutes.js and in express.Router() we can specify some options and we set mergeParams to true.

Why we need this option there?
It's because by default, each router only has access to the parameters of their specific routes. But there, in the '/' route in reviewRoutes, for POST,
there's no :tourId, but we still want to get access to the :tourId that was in that other router which is tourRouter,
Learn: so in order to get access to that parameter in that OTHER ROUTER, we need to merge the parameters and that's what mergeParams: true does.

Important: Now, no matter if we get a route like: POST /tour/:tourId/review or /reviews, it will now all end up in that .post() handler in
 reviewRoutes, so to createReview handler function.
and again that works because all of the routes starting with /tour/:tourId pattern will be redirected to the review router, because of
router.use('/:tourId/reviews', reviewRouter) line of code in tourRoutes. So with that code, we redirect it to review router and there it will match the '/' route.
And thanks to mergeParams: true, we then get access to that :tourId which comes from the other router before.

Now create a new review and then check the tour to see if it gets this new review.

Now we're gonna adapt the handler function for getting all the reviews for a specific tour, in the next video.

Note: Start the route with a slash, so '/:tourId/reviews' not ':tourId/reviews'.*/
/* 161-14. Adding a Nested GET Endpoint:
We created a nested POST endpoint in order to create new reviews on a certain tour. So let's now build upon that and also create a nested
GET endpoint.

Currently, getAllReviews handler only gets an array of all the reviews in the review collection.
Now a common use case for our API, might be to get an array of all the reviews of one particular tour, so very similar to the createReview.
So similar to POST '/tour/:tourId/reviews', but except with GET.

Now all we need to do in order to implement this, is to do some changes to getAllReviews handler function. Because right now thanks to the mergeParams: true
and that kind of redirecting with router.use() in tourRoutes, that getAllReviews handler function will now automatically get called, whenever there is a
GET request for a URL like: /tour/:tourId/reviews and will also get access to the :tourId thanks to mergeParams: true .
The changes:
check if there is a tourId in params and if there is one, then we're only gonna search for reviews where the tour is equal to that tourId.
So if there is a req.params.tourId, then we want to create a filter object which we will then later use in that find() and so then only the reviews
where the tour matches the id, are going to be found.

If it's our regular api call without nested route, well then that filter will simply be an empty object and so then we're gonna find ALL the reviews.

Now let's test this. You should get all the reviews that are present on that PARTICULAR tour.*/
/* 162-15. Building Handler Factory Functions Delete:
We're gonna build a handler factory function in order to delete review documents, but also documents from all the other collections, all with one simple
function.

Adding very similar handlers to all of our controllers, will create a lot of duplicate code. Because all those update handlers, or all those delete handlers
or all those create handlers, they really all just look basically the same. Also imagine that we wanted to change like some http status code or status message.
Then we would have to go into each and every controller and then change all the handlers in there and so, instead of manually writing all those handlers,
why not create a factory function that's gonna return those handlers for us?
Learn: A factory function is a function that returns another function
and in this case, our handler function. So for deleting, for creating, for updating and also for reading resources.

Copy the deleteTour handler as a template for us to follow. Then create a new file in controllers called handlerFactory and I'm doing this in the controllers folder,
because the functions that we're gonna write there, will return controllers, so it makes a lot of sense to put them in controllers folder.

The goal is to create a function which will then return a function that looks like the deleteTour, but not only for the tour, but for every
single model that we have in our application and that we might have in the future.
So that function needs to be prepared for that and what that means is that inside the facotry function, we will pass in the model.
Let's call our factory function `deleteOne` and it's called like this, again, because that function is not only going to work to delete tours,
but also to delete other documents.

This works because of javascript closures which is just a fancy way of saying that that inner function(like the function we return in a factory function),
will get access to the variables of the outer function, even after the outer has already returned.

Calling factory.deleteOne() will then return another function which will then sit there and wait until it is finally called as soon as we hit the
corresponding route and now let's try exactly that in postman and delete a tour.

Only the administrator should later be able to delete users, because remember that when the user deletes himself, then they will NOT actually get
deleted, but only `active` will be set to false. But the administrator on the other hand, is really gonna be able to delete the user effectively
from the database, we're gonna be worry about the permission stuff a bit later.

If you try to delete a user that is no longer there, we should get an error which says: No document found with that id.

Each and every single endpoint that we're implementing, I'm also adding it into postman, because a bit later, we will then be able
to create some API documentation based on all of them that we have saved in postman and that's yet another handy feature of that application.

Delete user route is just for administration but delete current user is for the currently logged in user, so very different.

This was a factory function only for deleting and only for deleting. Next, we're gonna implement factory function for updating and for creating docs.*/
/* 166-16. Factory Functions Update and Create:
Let's create some factories for getting documents and let's start with getOne.
This one is a bit trickier, because we have a populate() in the getTour() handler which is different from all the other get handlers in the other
resources.
Important: But this is not a problem. Because we will simply allow ourselves to PASS IN a populate options object into our getOne function.
So instead of simply passing in the model, we will also have populate options.

Copy a normal get one entity handler function from getTour.

In that handler, we will first create the query and then if there is the populate options object, we will then add that to the query and then by the end,
await for that query.

So this logic that we have in getOne factory function with NOT awaiting the query RIGHT AWAY, but instead just saving it into a variable, so that
we can then, in the next step, manipulate it. We actually already did this kind of stuff before when we were building our API features.
So ONLY IN THE END, when the entire query is ready, we will then await it and store it somewhere in a variable.

The `path` property in populate() is the field that we want to populate and then we can also specify `select` which with this, we can specify which of
the fields we actually want to get.

Now create a getAll factory function. Copy the original code from getAllTours because it is the one that is really complete, because it has all those api features.

The getAllReviews handler has some lines of code that all the other getAll handlers do not have and what we're gonna do there is to copy that code which doesn't
exist in other getAll handlers, into our handler factory as well. That's kind of a hack, because we really only need that code for getAllReviews and not other
getAll handlers, but to get around this, would be a bit too much work and once more, we want to keep it simple.
Also we need to pass that filter variable in getAll factory, to find() .

Let's now add a route for update a user in postman.

Now create the createOne factory function and you can get it's base code from createTour function. Then replace the code for createTour with the
createOne factory function.

So now our code in the controllers is now getting clean, but we're not gonna be able to replace ALL of the functions that we have in controllers with
factories, because otherwise, we wouldn't even need those controller files. Right? We could then simply create those handlers on the fly in the router files and
so we could basically skip that entire step of the controller file. But again, we still need it, because we have some other stuff in the controller functions,
for example in getTourStats and getMonthlyPlan and ... , so it makes sense to keep those files.

For the users resource, we do not need the createOne factory, because for creating new users, we already have the signup function and we can't replace that
with a factory, because it really is different from that generic factory.

In createReview handler, we have some code that is not in more generic createOne factory function. So how can we fix that?
We can create a middleware that is going to run before the createReview and that also makes it a bit more decoupled. So that additional code is gonna be
in it's own function and really decoupled from createReview code, because it doesn't have much to do with creating the review, it simply sets some data.
So create the setTourUserIds middleware and the responsibility of it, is to set tour and user ids. Or in other words, we set those ids on the body and then
move straight to the next middleware, where then the review eis actually created.

Now we need to create factory functions for getting one and getting all documents of a certain resource.*/
/* 167-18. Adding a me Endpoint:
It's a good practice to implement a /me endpoint in any api. So an endpoint where a user can retrieve his own data.
It's gonna be sth very similar to updateMe and deleteMe endpoints that we already have(the handlers for those endpoints actually).
Create getMe handler function.

We want to use .getOne factory function, because otherwise it would be similar code. The only problem with this one is that getOne() uses the id coming from
the parameter in order to get the requested doc. But what we want to do now, is to get the document based on the current user id. So the id comging from the
currently logged in user and so that way, we don't have to pass in any id as a url parameter.
So how can we do that?
All we do, is a very simple middleware which in there, we say: req.params.id(which is the one that getOne is gonna use) and set it to req.user.id and then
we will then add that middleware before calling getOne() .

Now in userRoutes, add a new route for get me and we named that url, '/me' and for this url, we need to first be logged in, so use authController.protect which will
add the user object to the current req object, which will then allow us to read the id from that user.
Then put that user id into the req.params.id . So basically faking that the id is actually coming from the url, so place userController.getMe middleware and
then finally place userController.getUser .

Now test it by creating a new request in postman and we need to set the Type in Authorization tab of postman, to Bearer Token.

With this route, we get the data about ourselves.

So again, you saw the great power of middleware, where it was so easy to implement the getMe middleware, so that then, after that, we can use our
simple getUser handler.*/
/* 168-19. Adding Missing Authentication and Authorization:
We need to fix some of the authentication and authorization in all our resources and we're gonna start with our tour resource and since all the
authentication and authorization stuff is always defined on the route declarations, we're gonna work on the tourRoutes.js file.

That tours api that we have, is what we want to expose to the world. For example we might want to allow other travel sites to embed our tours
into their own website and so that's what this api is basically for and so we will not have any authorization on 'get tour' requests. So get rid of
authController.protect from the getAllTours route.
Again: On getting all the tours route, right now we have it protected and so only the authenticated users can use that. But again, that doesn't make sense, because
you want to expose that part of the API to everyone, so get rid of that.

However, the actions of creating or editing tours, we only want to allow lead guides and administrators to perform these actions. So of course, no normal users and
also no normal guides, so just admins and lead guides. So use the restrictTo() on createTour handler.

Next, we want to do the same with editing a tour route.

Everything else, even getting just one single tour, is of course free to everyone and the same goes for getting the top tours route and also getting the
tour statistics route.
Now about get monthly plan, we also might want to restrict that only for example to everyone except normal users.

Signing up, logging in, forget password and reset password are open to everyone. For none of these, you need to be logged in. But you need to be logged in,
so to be authenticated, to update your password, to get your own information, to update or delete your own account and ... . So we don't want the
public to get information about all the users. We also don't want anyone to delete users or to update users and so none of these operations should be
free for the public. So for those not-public routes, you will always have to be authenticated.

We could go ahead and add that protect middleware to all of those routes, but we can do better than that. In order to do that,
keep in mind that that protect function is just a middleware and also remember, learn: that middleware runs always in sequence.
Now the router in userRoutes that we created in the beginning, is kind of like a mini application and so just like with the regular app,
we can use middleware on that router variable as well. So we can do sth like:
router.use(authController.protect);
Important: and this will protect all the routes that come after that router.use(authController.protect); and again that's because middleware, runs in sequence and
 so after those 4 middleware functions(/signup, /login, /forgotPassword, /resetPassword/:token)(remember that they are still middleware), the next middleware in
 the stack is that authController.protect which is used in router.use() and that will then only call the next middleware, if the user is authenticated and the
 next middleware in this case, is router.patch('/updateMyPassword', ...);
So all of the routes that come after that router.use(authController.protect);, are now protected, so we can remove authController.protect from all of them.

That's a trick to protect ALL of the routes(which are middlewares) at the same time, simply by using a middleware that comes BEFORE all those other routes.

For example if you move that router.use(authController.protect); before /forgetPassword , you need to be logged in, in order to use forgetPassword route!!! which doesn't
make sense at all!

It's crucial to mark the routes that need the users to be logged in, in their Authorization tab to use the Bearer Token, because of api documentation that we're
gonna generate based on the saved routes in postman.
Note: For get all tours and get a tour reqs, we no longer need any authentication, so remove the Bearer Token in Authorization tab of that req in postman, so set it to
Inherit auth from parent.

We want no one whose not authenticated, to GET or POST or ... any reviews, so we used router.use(authController.protect); in the beginning, so we removed
authController.protect from the routes after that router.use(...); .

Now about authorization, only users should be able to POST reviews. No guides and also no administrators.
Then admins should be able to update or to delete reviews, just like regular users, so that they can then edit or delete their own reviews and
finally, guides can not add, edit or delete reviews. Since the guides are the ones who are performing the job, so it would be weird if they could POST
reviews themselves or edit other people's reviews!!!

Guides and lead-guides have nothing to do at all with reviews. All they can do is to really GET reviews, but not changing pr POSTING them at all.

The reqs in Tour/Review folder(the nested routes), need to have authentication, because ultimately it's the review handlers that are called for both of those reqs.

So now the only way of getting access to data about reviews, is to call all of the tours request(at least for people that are not authenticated).

In updateOne factory, the {data: doc} object is called envelope. */
/* 169-20. Importing Review and User Data:
In dev-data folder, we already imported all the tours, but we also have a users.json and a reviews.json , so we need to update the import-dev-data.js
script.

First run: node ./dev-data/data/import-dev-data.js --delete
to delete everything we have currently. Then take a look at the compass.

Now run: node ./dev-data/data/import-dev-data.js --import
But now we get an error that says: passwordConfirm: ValidatorError: Please confirm your password and that's because we're creating a new user without
specifying the passwordConfirm property. The solution to that is to explicitly turn off the validation in this case and for this, we need to
pass in an object when using Model.create() as the second argument and with validateBeforeSave: false, all of the validation that we do in the model,
will just be skipped, also another thing that we need to do in the model, is to turn off the password encryption. Because the users that we provide
ALREADY have an encrypted password. So comment those two pre save middlewares in user model file.

Now delete the data again, so we don't create any duplicates and then run the import command.

Now uncomment those pre save middlewares in userModel.js .

Now in postman, login as the administrator and the password for all of the users is: test1234.

So now we have more real world data.*/
/* 170-21. Improving Read Performance with Indexes:
Read performance in mongodb and why sth called indexes are crucial and how we can create them ourselves?

In getAll() of handlerFactory.js , after await features.query, call explain() .
Now if you send a req like get all tours by saying: /api/v1/tours?price[lt]=1000, you would get a completely different result which in this case would be
some statistics.
Look at executionStats property and there, you can see the number of documents that were returned, were 3 for example and so that's exactly the result that we got
before, so before doing the explain() . But the number of documents that were examined(totalDocsExamined property) is 9(in case of tutor's) and this means
that mongodb had to examine, so basically to SCAN all of the nine documents, in order to find the correct 3 ones, so the 3 ones that match the query and so that's
not efficient at all.
Now of course at this scale, with only 9 docs it makes absolutely no difference, but if we had hundreds of thousands or even millions of docs there,
then this would significantly affect the read performance of that query.

With indexes, we will be able to kind of solve this problem. We can create indexes on specific fields in a collection. For example mongo automatically creates an
index on the _id field by default and in compass you can see it by going to the indexes tab of a collection. That _id index is an ordered list
of all the _ids that get stored somewhere outside of the collection and you can see the size for example 36 kb and that index is useful, because
whenever docs are queried by the _id , mongodb will search that ordered index instead of searching through the whole collection and look at all the
documents one by one, which is of course much slower.
So again, without an index, mongo has to look at each document one by one, but with an index on the field that we are querying for, this process becomes much
more efficient and we can set our own indexes on fields that we query very often.
Let's do that with the price field that we just queried for before, because tutor believes that it is one of the most crucial that people will query for.

In tour model and right after the schema declaration, use index() on schema variable and pass it an object with the name of the field and for the value of
that field, either 1 or -1 and 1 means that we're sorting the price index in an ascending order, while the -1 stands for descending order and there are
other types of indexes as well, like for text or for geospatial data, but we will see that a bit later.

Note: After writing the code for declaring a new index on a field, send the request multiple times to make sure the index is really set, because sometimes
it is not set right away.

Now send the req for getting all tours again with explain() and you still see that we still get our number of returned or nReturned at 3, but this time,
the number of documents that were examined, so that were scanned(totalDocsExamined), were only 3! and so that proves that with this index, we achieved exactly
what we wanted. So before, we had to scan through all of the 9 documents and now the engine only needs to scan the three documents that are actually also returned and
again, because their prices are now ordered in that index and so that makes it much easier and faster for the mongodb engine to find them and this is a huge performance
gain.

Now tutor reloads the collection and even the whole database from the button in top left, but still the new index doesn't appear in indexes tab of compass!
But that doesn't matter, because we already know that the index is actually working! So it's completely normal that sometimes this takes some time to update.

Now in indexes tab of compass, you can see that the _id index is having a property called unique and unique is also a property that we can give to indexes and
this is actually the reason why the _ids have always to be unique. So simply because the index of the _id has this unique property. You also noticed that
there is an index for the name in tours collection, but we didn't create that manually ourselves!
So why it is there?
Because in our schema definition, we set the name field to be unique and so what mongoose then does behind the scenes in order to ensure the
uniqueness of that field, is to create a unique index for it and so because of that, not only the _id , but also the name always have to be unique(in case of tours
collection).

So when all we ever do is to just query for one single field alone, then a single field index is perfect. Because remember the index that we just set
before, is called a single field index.
If we sometimes query for that field, but combined with another one, then it's more efficient to create a compound index. So one with two fields and not just one.

Let's create a query for that just to illustrate it.
Another field that I think is going to be queried for all the time, is the ratingsAverage. So now send a req with this url(which would send statistics, because of
explain()):
{{URL}}/api/v1/tours?price[lt]=1000&ratingsAverage[gte]=4.7
We got nReturned which is the number of results(the number of docs that are returned, so that match this query) as 2. But we still had to examine 3 docs(totalDocsExamined).
For fixing this, we're gonna use a compound index.
So comment the first index that we created and then create a compound one and after that, for sending the request, do it a couple of times instead of once.
Now in the case of tutor's, only 2 documents were scanned(totalDocsExamined) in order to find the two documents(nReturned property) that we were actually looking for.

This compound index, is also going to work when we query for just one of those two fields individually(price or ratingsAverage).
Important: So when we create a compound index like this, we do not have to then create one individual for each of the fields as well.

One thing that in the case of tutor's is interesting is that in the top right corner in compasse's indexes tab, you can see the
total size of indexes which in the case of tutor's is 72kb which is way bigger than the size of all the docs combined in that collection(9 docs in case of tutor's)
which have total size of 14.4KB.
So those indexes in that collection that we create to search the documents, take up a lot more space than the docs themselves! But again, that's just because
we're operating on such a small scale in this example and so that's not really relevant.

How do we decide which field we need to index? and why don't we set indexes on all the fields?
We kind of used the strategy that I used to set the indexes on the price and on the averageRating. So we need to study the access patterns
of our app in order to figure out which fields are queried the most and then set the indexes for these fields.
For example, we're not setting an index on the groupSize, because I don't really believe that many people will query for that parameter and so I don't need to
create an index there, because we really do not want to overdo it with indexes. So we don't want to blindly set indexes on all the fields and then hope for the best!
and the reason for that is that each index actually uses resources, so as you can see here with the Total size of indexes.
Important: And also, each index needs to be updated, each time that the underlying collection is updated.
So if you have a collection with a high write/read ratio, so a collection that is mostly written to, then it would make absolutely no sense to create an index on
any field in this collection. Because the cost of always updating the index an keeping it in memory clearly outweighs the benefit of having the index in the first
place, if we rarely have searches, so have queries, for that collection.
So in summary, when deciding whether to index a certain field or not, we must kind of balance the frequency of queries using that exact field, with the cost of
maintaining this index and also with the read/write pattern of the resource. However, just like it is with data modeling,
there are not really hard rules here.

Whatever you do, please don't just ignore indexing, because even if it's not perfect, it will always have a huge beneift for your app.

Create an index for query slug, because later on, we will want to use the unique slug to query for tours. So meaning that the slug will then probably
become the most queried field and so it makes all the sense to also have an index for that one.

Most times, the 1 or -1 for index is not that crucial.

If the compass doesn't update the newly created index in it's indexes tab, you can try to connect to the database again through connect>connect to and you can find the
info for connecting from the most recent ones.

Note: If you HAD an index in the code in the past and then remove that code, the index will remain in database! So it's not enough to remove the index from our code,
we really need to delete it from the database itself(we had it in the beginning and then we commented it out, but it's still in the db!).

Indexes can make the read performance on dbs better.

Now comment out the explain() from getAll factory.*/
/* 171-22. Calculating Average Rating on Tours - Part 1:
Let's calculate averageRatings.
So storing a summary of a related dataset on the main dataset is a popular technique in data modeling and this technique can be helpful
in order to prevent constant queries of the related dataset.
In our app, an example of this technique is to store the averageRatings and the number of ratings on each tour, so that we don't have to query the reviews
and calculate that average each time that we query for all the tours. For example, that could become useful for a tour overview page in our front-end,
where we really do not want to display all the reviews, but still want to show a summary of these reviews, like for example the number of ratings and the
average and actually we already have the fields for that in our tourSchema which are ratingsAverage and ratingsQuantity. But right now, they're only just some
numbers and of course, they are not the actual average and the number of ratings, because we never really calculated that at any point in our app, but that's
exactly what we're gonna change in this video.
So right now, we're gonna calculate the average rating and also the number of ratings of a tour. each time that a new review is added to that tour, or also when a
review is updated or deleted, because that's exactly the situations when the number or the average might change.

In reviewModel, create a new function which will take in a tour id and calculate the average rating and the number of ratings that exist in our collection for that
exact tour. Then in the end the function will even update the corresponding tour document, then in order to use that function,
we will use middleware to call this function each time that there is a new review or one is updated or deleted.

For writing that function, we're gonna write a static method on our schema and that's a feature of mongoose that we hadn't used yet, so we only used instance
method, which we can call on docs and they are also useful, but this time, we're really gonna use static methods and these can be called on the model directly for
example like: <model variable>.statics.<name of static method> = function () {}  and this function takes the tour id and that id is for the tour to which the
current review belongs to.

In order to do the calculation, we will again use the aggregation pipeline.
Important: We use the aggregate() method on a model variable(on the model itself) which we call directly on the model itself.
Important: In a static method on a model, the this keyword points to the current model and that's why we can use this.aggregate() inside a static method,
 because remember we need to call this.aggregate() on the model directly and that's exactly why we're using a static method there in the first place.
 Because again, `this` now points to the model and we need to call aggregate() always on the model.

Into aggregate() , we need to pass in an array of all the stages that we want in aggregate .
In aggregate of reviewModel, the first step(stage) should be to select all the reviews that actually belong to the current tour that was passed in as the argument.
So our first stage is a $match stage and to that $match, we pass our filter object and for that we pass: {tour: tourId}
and with that, we only select the tour that we actually want to update.

In the next stage, let's calculate the statistics themselves and for that, we use a $group stage and in the $group phase, remember the first
field that we need to specify is the _id and then the common field that all of the docs have in common that we want to group by, and so that's again
going to be the 'tour' field, so: '$tour'.
Important: So with: {$group: {_id: '$tour'}}, we grouped by the tour field.

For example in getTourStat's aggregate pipeline's $group, where we have: _id: {$toUpper: 'difficulty'} , we grouped by the difficulty and so like this,
we calculate the statistics for easy and statistics for medium and statistics for difficult tours. So in that example, we grouped all the tours
together by their difficulty.
But now in reviewModel's static method, we're grouping all the tours together by tour.

When we have: nRating: {$sum: 1}, it means: add 1 for each tour that we have, so each tour that was matched in the previous step or stage(nRating means number of
ratings). So if there are five review docs for the current tour, then for each of those docs, 1 will get added, so then in the end, the number of ratings or
nRating will be 5 and again, because of course, we have 5 review docs.

For $avg operator, we specify the name of the field with a $ in the beginning. Remember each review has a rating field and that's where we want to calculate the
average from.

So number of ratings and average of ratings are exactly what we wanted to calculate in this aggregation.

In a later step, we want to update the tour document with those statistics. But I'm gonna leave that for a bit later, because for now, we need to call
that static method somewhere, because otherwise the statistics that we calculated in that static method will never get used and we will call it using a middleware
each time that a new review is created, so create a pre save middleware on reviewSchema.

In a pre save middleware, the `this` keyword points to the document that is currently being saved and so we will want to call the calcAverageRating function
using this.tour .
Now how are we going to call this function?
Remember that that function is available on the model, so like: Review.calcAverageRatings()
When we have: this.tour in that pre save middleware:
`this` points to the current review and therefore this.tour is the tour id that we're gonna pass to the calcAverageRatings() .
So we would write: Review.calcAverageRatings(this.tour);

Now the problem is that at that point when we defined the pre save middleware, the Review variable is not yet defined. Now you might think that the solution would
be to move that pre save middleware AFTER the Review variable declaration and initialization, but unfortunately that's not gonna work, because just like in express,
that code(the pre save middleware) runs in the sequence it is declared and so if we were to put that pre save middleware after the Review variable declaration,
then that reviewSchema would not contain that pre save middleware. Because we would then only be declaring it AFTER the Review model was already created.
But there is fortunately still a way around this and that is to use: this.constructor in that pre save middleware and `this.constructor` still points to the MODEL inside
that pre save middleware. WHY?
Because we know that `this` in a pre save middleware points to the current document and the constructor is the model who created that document.
So this.constructor stands for the Review I guess(tutor said Tour!).

Now let's test this and for that, create a new tour first. because the other ones that we already have, they have the average and number of ratings
already calculated and so we want to start from scratch here when testing this out.
To create the new tour, we need to be logged in as administrators and after creating a new tour, you see some defaults that we set before like
ratingsAverage set to 4.5 and the ratingsQuantity set to 0.

Now in order to create a new review, we need to be logged in as a regular user, then create a new review on tour, by using this route:
/api/v1/tours/:id/reviews

Then look at the console and it is sth like: [ { _id: 5c8a1f292f8fb814b56fa184, nRating: 2, avgRating: x } ]
The next time you create a review for a tour, the result of stats would be: [ { _id: 5c8a1f292f8fb814b56fa184, nRating: 4, avgRating: x } ]

Important: We shouldn't use PRE save middleware and instead post. Because at pre save, the current review is not really in the collection yet and therefore
 when we then do that $match , it shouldn't be able to then appear in the output, because again at that point in time, it's not really saved into the
 collection just yet.
So it's best to use post middleware because at that time, all the docs are already saved in the db and so that's then a great time to do this calculation
with all the reviews already and then store the result on the tour.

Note: The post middleware does not get access to the next argument which we could use to call the next middleware.

So now, we're correctly calculating the statistics, but they're not yet being persisted to the current tour document.
Because the tours that we created still have the default values of 4.5 and 0 for avg and number of ratings.
So now we want to persist the calculated statistics into the tour document.

For doing that, first of all, require the Tour model into the reviewModel file.

Now in calcAverageRatings, we need to find the current tour and then update it.

We didn't store the result of await Tour.findByIdAndUpdate , into a variable, because we don't need to do anything with it.

Now create a new review for a tour.
Now see the tour that you created a review for it to see average rating and number of ratings for it, by using "get tour" route.

Recap: We started by creating a static method on Review model to create the statistics of the average and number of ratings for the tourId for which the
current review was created and we created that function as a static method, because we needed to call the aggregate() on the model and in a static method on
model, the `this` keyword calls exactly to a method(the model?!) and so it's handy in these cases.

So we constructed oru aggregation pipeline, where we selected all the reviews that matched the current tourId and then calculated the statistics for all the
reviews in the $group stage. Then we saved the statistics to the current tour that a review was created for that tour.
Then in order to use this static method, we call it after a new review has been created, so a post save middleware and for that, we need to use
this.constructor, because `this.constructor` points to the current model in a post save middleware.

We also want to update the statistics whenever a review is EDITED or DELETED. Because these actions will of course, also influence the number and the average of
ratings. However, doing so is a bit more complex. So we do it in next video. */
/* 172-23. Calculating Average Rating on Tours - Part 2:
Calculating the review statistics, this time for when a review is updated or deleted and this part is harder because keep in mind that a review
is updated or deleted using findByIdAndUpdate() , or also findByIdAndDelete() and for these, we actually do not have document middleware, but only
query middleware and so in the query, we don't have direct access to the document, in order to then do sth similar to:
this.constructor.calcAverageRatings(this.tour); . Because we need access to the current review, so that from there, we can extract the tour id
and then calculate the statistics from there. But again, for the findByIdAndUpdate() and also findByIdAndDelete() , we only have query middleware.

But let's see a nice trick to go around this limitation.
For this, we're gonna implement a pre-middleware for those events(findByIdAndUpdate() , or also findByIdAndDelete()) and we're gonna use a regular expression.
Important: So write a pre middleware in reviewModel and the regex is /^findOneAnd/ which is gonna work for findOneAndUpdate and findOneAndDelete. Because remember that
 behind the scenes, findByIdAndUpdate is only just a shorthand for findOneAndUpdate() with the current id. So there, we actually need to use the findOneAndDelete and
 findOneAndUpdate middleware hooks. So we didn't write a regexp like: /findById.../ , instead we wrote for it's actual meaning(findByIdAndUpdate is just a SHORTHAND,
 so we wrote for it's actual meaning).

The pre middlewares get the next argument not the post ones.

The goal is to get access to the current review doc, but there(in pre findOneAnd middleware), `this` keyword is the current query.
Now how are we gonna go around this?
Important: We can execute the query and then that will give us the document that's currently being processed.
So in order to do that, we can use findOne() and then we await that query and save it somewhere and we store it in r variable which stands for review.

So basically the trick of going around that in a query middleware, we only have access to the query.
So again, we need to get access to the document and so we execute that query(this keyword by using findOne() .

Now you can test this by using the update review route. Now you get the updated review. Now of course the rating is still set to 5 at that point,
because that findOne() really gets the document from the database and so at that point of time, in pre middleware, it still didn't persist any changes
to the database and so it was 5 before and so now it's still gonna be 5. But that doesn't really matter there, because all we are interested in, is the
tour field which is the id of tour, because that is what we're gonna need in order to calculate the average ratings.

Now if we were to use the calcAverageRatings() function at this point of time in pre middleware of /^findOneAnd/, then we would calculate the statstics
using the non-updated data and so that's the exact same reason why up here, we also needed to use post and not pre, because only after the document is already
saved to the database, it makes sense to then calculate the ratings and so in pre middleware, it's the exact same thing, with the big difference that we
cannot simply change that pre to post. Because at that point of time(with post), we no longer have access to the query, because the query has already
executed and so without the query, we cannot save the review document and we can not then run that calcAverageRatings() function.

The solution for this is to now use post and at that point of time, so after the query has already finished and so the review has been updated,
this is a perfect point in time where we can then call that calcAverageRatings function. But where do we now get the tour id from?
We're gonna have to use a trick which is to pass data from the pre-middleware to the post-middleware and so instead of saving the result of
await this.findOne() to a variable, we're gonna save it to this.r . So basically we create a property on `this` and so in the post-middleware,
we still have access to that and we can say: this.r in that post-middleware and this.r is the review.

Recap: We need sth like: this.constructor in order to call that calcAverageRatings() static method in the post findOneAnd middleware, because
remember that calcAverageRatings() is a static method and so we need to call it on the model itself. Now where is that model in the case of a
post findOneAnd middleware?
It's at this.r which in this case is equivalent to `this` in the post save middleware. So we can use .constructor on the this.r .

We have to do it this way, because at the post findOneAnd middleware, the query was already executed and so we could not do await this.findOne() in post
findOneAnd middleware.

Now to test this, update a review and change it's rating and the avgRating should change on the tour document too.

So it works great on update, let's also test it with deleting. So delete the test review with delete review route.

Currently, if there are no docs matching that $match stage, then we get back an empty array, so the stats array would be empty and we get an error when
we say: stats[0].nRatings, so add an if statement and the else statement means that all our reviews are gone and we want to go back to the default.

To test this, create a new review with create a new review for a tour route.

Recap: In order to be able to run calcAverageRatings() static method also on update and delete, we need to use the query middleware
that mongoose gives us for these situations. So we do not have a handy document middleware which works for those update and delete functions,
but instead, we need to use the query middleware and in that one, we do not directly have access to the current doc and so we need to go around that
by using that findOne() in pre middleware of findOneAnd and so retrieving the current document from the db. Then we store it on the current query variable which
is the `this` keyword(in pre findOneAnd middleware) and by doing that, we then get access to it in the post middleware and it's then only in the post
middleware where we calculate the statists for reviews and remember we do it this way, because if we did it right in that PRE findOneAnd middleware function,
then the underlying data would not have been updated at that point, so the calculated statstics would not really be up to date and so that's why
we used this two-step process.*/
/* 173-24. Preventing Duplicate Reviews:
We're gonna use a trick in order to prevent users from writing multiple reviews for the same tours. So basically preventing duplicate reviews.
So we(and users) shouldn't create multiple reviews for one tour, so this shouldn't be done from the SAME user.
So in the real world, each user should only review each tour once, so basically a duplicate review happens when there is a review with the same user and the same tour id.
The obvious solution is to just use a unique index, however it is not enough to set both these fields to unique and actually that would really be wrong, because that
would mean that each tour can get only one review and each user can only write one review and obviously that's not what we want.
What we do need, is them BOTH TOGETHER to be unique. So the combination of user and tour to be always unique and this is easy to acheive with indexes.
We already created a compound index on the tour before and so now let's do the same on the reviews.

Right after the schema definition(still in the reviewModel file) use the index() on the variable that holds the schema and in this case, setting tour to 1 or
-1 in index doesn't matter.

With reviewSchema.index({tour: 1, user: 1}, {unique: true}); , each combination of tour and user, has always to be unique.

Now for testing this, it maybe doesn't work right away, it maybe start to work the next day.
For testing this, create a new review on tour with a user and then if for the second time, with that exact user, you create a new review for that tour,
then it shouldn't be allowed to work. Just keep in mind that it might still work, because of the issue that I mentioned!
So sometimes, the indexes doesn't get SET immediately.
But if it works, it should say: Duplicate key error collection: natours.reviews index: tour_1_user_1

If you don't see the newly created index in compass indexes tab, you can reconnect to database, but maybe it doesn't work still!

So now we will not able to create two reviews coming from the same user. In other words, one user cannot write multiple reviews for the same tour.

Sometimes, the ratingsAverage becomes a floating number with too many decimal numbers and we could fix this in the frontend for example when we
request that data from the api and then display it, we could on the frontend then do a rounding, but we want to do it right on the backend, so that
the end user already gets this final rounded value and for doing that, there's a small new feature in mongoose. For that, go to tourModel and to ratingsAverage field
and we can use a setter function with the `set` property that has a function as value and that function will be run each time
that a new value is set for that field and there, we usually specify a callback function which receives the current value.

The problem with Math.round() is that it rounds values to integers, so for example if the value is 4.666666 it would then round it to 5 and that's not what we want,
we want it to be 4.7 and so we're gonna use a trick which is multiply it by 10 which would be 46.6666 which when is rounded, would be 47 and then we divide it
by 10 again.

In this case, the setter function is gonna re-run each time that there is a new value for the ratingsAverage field.*/
/* 174-25. Geospatial Queries Finding Tours Within Radius:
We're gonna look at the geospatial queries in order to implement a feature which is to provide a search functionality for tours within a certain
distance of a specified point.
Let's say you live in a certain point and wanted to know which tours start a certain distance from you like 250 miles , because you don't want to
drive further than that in order to start your tour experience.

In tour router, create a nice route and put it before the general routes there, called /tours-within/:distance/center/:latlng
:latlng is the point where you live , in other words, :latlng is the coordinates of the place where you are.
Let's say you live in Los Angeles and wanted to find all the tours within a distance of 300 miles. So :distance would be 300 and :latlng would be
the coordinates of where you live.

Also provide the option of specifying the unit, so if either the distance is in kilometers or in miles.

This way of specifying the url like /center/:latlng or /unit/:unit and of course we could make it so that the user should specify all of these options
using a query string, but this way it looks way cleaner and it's also kind of a standard way of specifying URLs which contain a lot of options.

So we could also specify the url with query strings like:
/tours-within?distance=233&center=34.111745,-118.113491&unit=mi

Now let's write the geospatial query itself, a geospatial query works quite similar to a regular query.
Now about the filter object we pass to .find() : remember we want to query for start location, because the startLocation field is what holds
the geospatial point, where each tour starts and so that's exactly what we're searching for and for the value of that, we now use a geospatial operator
called $geoWithin and this operator finds docs within a certain geometry and that geometry is what we need to define as a next step.
So we want to find docs, but where do we want to find these docs?
Well, we want to find them inside of a sphere that starts at latlng variable and which has a radius of the distance variable.

The $centerSphere operator takes an array of the coordinates and of the radius.
Important: For coordinates, we need yet another array and remember that we FIRST need to always define the longitude and THEN latitude which is a bit
 counterintuitive, because usually coordinate pairs are always specified with the latitude first and the longitude second, but in geoJSON?, it for some
 reason works the other way around.

So that was the center of sphere, now we need to specify it's radius.
Now we do not pass in the distance, but instead, mongodb expects a radius in a special unit called radians.

The radius is the distance that we want to have as the radius, but converted to a special unit called radians and in order to get the radians,
we need to divide our distance by the radius of the earth.
Now we need to take into consideration our units here, because of course the radius of the earth is different in miles and in kilometers. So we can create a
ternary operator.

distance variable is our original radius.

The radius of earth in miles is 3963.2 and in kilometers, it's 6378.1 .

So this conversion is necessary because mongodb expects the radius of our sphere to be in radians and we get radians by dividing the distance
by the radius of the earth.

In order to be able to do geospatial queries, we need to first attribute an index to the field where the geospatial data that we 're searching for, is stored.
So in this case, we need to add an index to startLocation field.
So do that in tourModel by using .index() on variable that holds the schema, but we're not going to set it to 1 or -1, because this time it is a different
index that we need.
For geospatial data, the startLocation index needs to be a 2D sphere index, if the data describes real points on a earth-like sphere, or instead,
we can also use a 2D index if we're using just fictional points on a simple two dimensional plane. Now in this case of course, we're talking about real
points on the earth's surface and so we're gonna use a 2D sphere index.
So with '2dsphere' index, we're telling mongodb that startLocation field should be indexed to a 2d sphere. So an earhlike sphere where all our data are
located.

Now test the route.

You can stop server npm script and run the debugger and you can set a breakpoint at the line where you have: if (!lat || !lng) {
Because at that point, we will have all our variables defined and so we can then take a look at their values.
Of course we could have done that with a simple console.log() , but in some situation where we have a lot of stuff going on, it's good to use the debugger.
Now send the request again to trigger the breakpoint.

Now the result of that endpoint tells us that there are those tours that are in that distance that we specified in the distance of url.

But how can we really know if that it's true?
We can use compass for this and go to schema tab of tours collection and then click on analyze schema and there we have a summary for all of our fields.

Now in startLocation field there, normally you would see a map there, but right now there is no map because we have a document right now which doesn't have
a startLocation. So in order for this to work properly, we need to get rid of that document and then go to schema tab and click on Analyze button again.
Then on the map, put the mouse cursor on where you want and then hold shift and then drag to draw a circle and if those points are INSIDE that circle, they will
become orange and then you can hit analyze button to return the result of drawing that circle and you can see the fields of results there.
So you can test the results that you got in postman, with the schema tab of compass.

We can see all of the locations on the map by using an empty filter in that tab and go to locations field there.

The bounding GeoJSON geometry is that sphere that we defined in our code.

With $near operator, we don't need to do the conversion to radians and with this operator, we can specify a minimum distance and so with this, we could
for example exclude tours that are only 50 miles away from our starting point.

So with this geospatial query that we defined, we found docs that are located within a certain distance of our starting point, but what if we wnated to know the
exact distance of all the tours TO that starting point?
We're gonna calculate this in the next video.*/
/* 175-26. Geospatial Aggregation Calculating Distances:
In last vid, we searched for tour docs within a certain distance from a certain point using geospatial queries.
In this video, let's use geospatial aggregation in order to calculate distances to all the tours from a certain point.

Create a route called /distances/:latlng/unit/:unit , so the data that we need is the latitude and longitude of the point where user currently is, and also we allow
the user to specify the unit.
So as you can see in the url of this route, this time, we do not need the distance parameter as we had it in the tours-within route, because we're not
gonna be searching from a certain radius. We're really gonna calculate the distance from a certain point to all the tours that we have in our collection.

Just like before, in order to do calculations, we always use the aggregation pipeline and it is called on the model itself.

For geospatial aggregation, there's only one single stage and that's called {$geoNear: ...}. So this is the only geospatial pipeline stage that exists and it
always needs to be the first one in the pipeline. So $geoNear alwasy needs to be the first stage.

$geoNear requires that at least one of our fields contains a geospatial index and we already did that before with the startLocation field which already has
the 2dsphere geospatial index on it and since we're using the startLocation in order to calculate the distances, that's then perfect.
Learn: If there's only one field with a geospatial index, then the $geoNEar stage will automatically use that index in order to perform the calculation.
 But if you have multiple fields with geospatial indexes, then you need to use the keys parameter in order to define the field that you want
 to use for calculations.
So again, in this case, we only have one field and so automatically that startLocation field is gonna be used for doing these calculations.

What do we need to pass to $geoNear?
First we need to specify the near property in the object that we pass to $geoNear and `near` is the point from which to calculate the distances. So all the distances
will be calculated between that point that we define in near property and then all the startLocations and so that near point is of course the point that
we pass into that getDistances handler, with latitude and longitude.

We need to specify the near point as geoJSON, where we need to specify the type as 'Point' and then specify the coordinates property and as always, the first
coordinate is the longitude in coordinates property and we multiplied both of them by 1 to convert it to numbers.

So the near property is the first mandatory field of the object we pass to $geoNear and the second one is the distanceField property and it is the name
of the field that will be created and where all the calculated distances will be stored.
That's all the fields that are mandatory in the $geoNear stage.

Of course we can add other stages after the $geoNear stage.

If you test this route, you will get this error: $geoNear is only valid as the first stage in a pipeline.
Now if you look at the code you might think that actually our $geoNear stage is currently the first stage of our pipeline!!!
There's nothing before it, so why do we get this error?
This has sth to do with a piece of code that we wrote a long time ago and in the aggregation middleware and remember that what that did is to always add
that $match stage before all the other stages and with that log there, our pipeline now looks like:
[
  { '$match': { secretTour: [Object] } },
  { '$geoNear': { near: [Object], distanceField: 'distance' } }
]
and so it makes sense that we get this error.

Now we could change that middleware and say that if $geoNEar is the first operator in the pipeline, then do not do that unshift() , but that's too much
work for this use case and all I'm gonna do is to get rid of that middleware.*/
/* 176-27. Creating API Documentation Using Postman:
The api is finished.
Click on publish docs on the collection. Then a browser window opens. We didn't want to use any environment anyway, because that would then replace our
environment variables with their real values and we don't want that. For example we used the env variable on the password, so that then later
in the documentation, it's not really visible. So we really want to use no environment.*/
